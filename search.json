[
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "R-ArcGIS Bridge",
    "section": "",
    "text": "{arcgisbinding} tutorial notebooks\nGeoprocessing tools using R scripts\n\n\n\n\n\nAuthorize to ArcGIS Online or an Enterprise Portal"
  },
  {
    "objectID": "tutorials.html#vignettes-tutorials",
    "href": "tutorials.html#vignettes-tutorials",
    "title": "R-ArcGIS Bridge",
    "section": "",
    "text": "{arcgisbinding} tutorial notebooks\nGeoprocessing tools using R scripts\n\n\n\n\n\nAuthorize to ArcGIS Online or an Enterprise Portal"
  },
  {
    "objectID": "tutorials.html#notes",
    "href": "tutorials.html#notes",
    "title": "R-ArcGIS Bridge",
    "section": "Notes",
    "text": "Notes\nTutorial/Workflow vs Vignette\nAnalogous to Python API\nVignette -&gt; Guide Tutorial -&gt; Sample\n\nTutorial would be a end to end process\n\nread in, manipulate, etc, then write back up to online\nHow to batch geocode and upload results to AGOL\nHow to create a GP tool (best practices)\nRead from an enterprise geodatabase / sde file\nusing R for something specific that you dont do in pro (for binding) or analysis tools\n\nVignette: how to understand / interact with a specific piece of code\n\nauthorization\ncreating new packages\n\ntips for developers"
  },
  {
    "objectID": "location-services/paper.html",
    "href": "location-services/paper.html",
    "title": "arcgislayers: an open source package for ArcGIS Location Services",
    "section": "",
    "text": "arcgislayers is an open source package as part of Environmental Systems Research Institute’s (Esri) R-ArcGIS Bridge project. arcgislayers enables developers to interact with ArcGIS data services directly from R. With arcgislayers, users can read, write, and administer remotely hosted data directly from R using native objects."
  },
  {
    "objectID": "location-services/paper.html#summary",
    "href": "location-services/paper.html#summary",
    "title": "arcgislayers: an open source package for ArcGIS Location Services",
    "section": "",
    "text": "arcgislayers is an open source package as part of Environmental Systems Research Institute’s (Esri) R-ArcGIS Bridge project. arcgislayers enables developers to interact with ArcGIS data services directly from R. With arcgislayers, users can read, write, and administer remotely hosted data directly from R using native objects."
  },
  {
    "objectID": "location-services/paper.html#statement-of-need",
    "href": "location-services/paper.html#statement-of-need",
    "title": "arcgislayers: an open source package for ArcGIS Location Services",
    "section": "Statement of need",
    "text": "Statement of need\nIn the evolving landscape of geospatial analysis, a critical shift towards cloud-native infrastructure has emerged, characterized by the exposure of data via REST APIs. Esri’s ArcGIS Location Services characterized by ArcGIS Platform embody this transition. Location services are accessible via REST API endpoints which which are language agnostic.\nWhile existing solutions like arcgisbinding enable reading and writing of ArcGIS hosted data, they present limitations (Aydin et al.). Notably, arcgisbinding relies on an ArcGIS Pro license which is confined to a Windows operating system, and does not support any additional administration of hosted data services.\nMoreover, the community-driven endeavors such as esri2sf, arcpullr, among others, strive to bridge this gap (CITE). However, these efforts fall short in delivering comprehensive, officially supported, and high-performance alternatives.\narcgislayers is an official, Esri-backed, open-source R package designed to interact with ArcGIS Image Servers and Feature Services. Leveraging the REST services offered by ArcGIS, arcgislayers empowers developers to seamlessly administer, read, and write data without the constraints of proprietary licenses or operating systems."
  },
  {
    "objectID": "location-services/paper.html#example-usage",
    "href": "location-services/paper.html#example-usage",
    "title": "arcgislayers: an open source package for ArcGIS Location Services",
    "section": "Example usage",
    "text": "Example usage\n\nlibrary(arcgislayers)\n\nurl &lt;- \"https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/PLACES_LocalData_for_BetterHealth/FeatureServer/0\"\n\nflayer &lt;- arc_open(url)\nflayer\n\n&lt;FeatureLayer &lt;28484 features, 154 fields&gt;&gt;\nName: PlacePoints\nGeometry Type: esriGeometryPoint\nCRS: 3785\nCapabilities: Query,Extract\n\n\n\nNotes\n\nAydin et al introduce arcgisbinding which provides a binding to ArcGIS pro enabling the reading and writing of ArcGIS Proprietary data formats and on the fly geospatial transformations using the transformation engine\nWe’re seeing a shift towards cloud-native geospatial analysisdata infrastructure which are exposed via rest apis\nEsri provides very useful technology via ArcGIS Location Services. Location services are exposed via rest APIs which are well documented. Endpoints can be both public or private depending on the hosting solution and authentication used.\nREST services provide a language agnostic interface to proprietary code allowing the development of completely open source bindings to the services\nWhile arcgisbinding provides a way for users of R and ArcGIS Pro to read image and feature services it is fairly limited. Noteably, the use of arcgisbinding requires an ArcGIS Pro license which itself requires a window machine. Further, arcgisbinding does not provide further capabilities for hosted data management.\narcgislayers builds upon the REST service provided by ArcGIS. arcgislayers is an open source R package for interacting with ArcGIS image servers and Feature services.\nthere are a number of community driven efforts to address this gap which are notably esri2sf, arcpullr, among others.\narcgislayers is an official, esri supported, and highly performant alternative to these packages"
  },
  {
    "objectID": "location-services/workflows/using-arcgis-arcgisbinding.html",
    "href": "location-services/workflows/using-arcgis-arcgisbinding.html",
    "title": "Using arcgis with arcgisbinding",
    "section": "",
    "text": "While both are components of the R-ArcGIS Bridge, arcgis and arcgisbinding serve distinct purposes:\nHowever, there may be instances where you want to combine the functionality of these two R packages in a single workflow. The below code samples demonstrate how these packages can be used together, as well as alongside popular spatial R packages like terra and sf."
  },
  {
    "objectID": "location-services/workflows/using-arcgis-arcgisbinding.html#extract-imagery-of-the-ouarkziz-crater",
    "href": "location-services/workflows/using-arcgis-arcgisbinding.html#extract-imagery-of-the-ouarkziz-crater",
    "title": "Using arcgis with arcgisbinding",
    "section": "Extract imagery of the Ouarkziz crater",
    "text": "Extract imagery of the Ouarkziz crater\nThis sample shows how to extract and resample multispectral Landsat imagery from ArcGIS Living Atlas using arcgis and arcgisbinding. Both packages also work with terra, so you can easily plot, write, and integrate with other R-based raster analysis workflows.\n\n# install.packages('arcgis')\n\nlibrary(terra)\nlibrary(raster)\nlibrary(arcgis)\nlibrary(arcgisbinding)\narc.check_product()\n\nproduct: ArcGIS Pro (13.2.0.49743)\nlicense: Advanced\nversion: 1.0.1.306 \n\n# ArcGIS Living Atlas Landsat2 imagery service URL \nrurl &lt;- \"https://landsat2.arcgis.com/arcgis/rest/services/Landsat/MS/ImageServer\"\n\n# use arcgis to extract the natural color imagery\nimg_srv &lt;- arc_open(rurl)\nimg_srv\n\n&lt;ImageServer &lt;11 bands, 26 fields&gt;&gt;\nName: Landsat/MS\nDescription: Multispectral Landsat image service covering the lan\nExtent: -20037507.07 20037507.84 -9694091.07 9691188.93 (xmin, xmax, ymin, ymax)\nResolution: 30 x 30\nCRS: 3857\nCapabilities: Catalog,Image,Metadata\n\nimg &lt;- arc_raster(\n  img_srv,\n  \"-846028\", # xmin\n  \"-833783\", # xmax\n  \"3373101\", # ymin\n  \"3380738\", # ymax\n)\nimg\n\nclass       : SpatRaster \ndimensions  : 400, 400, 11  (nrow, ncol, nlyr)\nresolution  : 30.6125, 30.6125  (x, y)\nextent      : -846028, -833783, 3370797, 3383042  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / Pseudo-Mercator (EPSG:3857) \nsource      : x_____xTRXJxJ6XbIPSrPxM-nRAvA..x_____x_ags_8564ca38_5048_4d92_ad3e_750f12824416.tif \nnames       : Coast~rosol, Blue, Green, Red, NearInfrared, Short~red_1, ... \n\n# use terra to view the imagery\nplotRGB(img, stretch = \"lin\")\n\n\n\n# use arcgisbinding to resample and view SWIR\nbbox &lt;- c(-846028, # xmin\n          3373101, # ymin\n          -833783, # xmax\n          3380738) # ymax\nresampled &lt;- arc.raster(arc.open(rurl), bands=1, nrow=300, ncol=300, resample_type=\"CubicConvolution\", extent=bbox)\nswir &lt;- as.raster(resampled)\nplot(swir)\n\n\n\n# use terra to write out the natural color & SWIR rasters\nwriteRaster(img, \"ouarkziz-crater-RGB.tif\", overwrite=TRUE)\nwriteRaster(swir, \"ouarkziz-crater-SWIR.tif\", overwrite=TRUE)\n\nData Source: Multispectral Landsat\nLearn more about the Ouarkziz crater in Algeria."
  },
  {
    "objectID": "location-services/workflows/using-arcgis-arcgisbinding.html#use-local-data-to-update-an-arcgis-online-feature-service",
    "href": "location-services/workflows/using-arcgis-arcgisbinding.html#use-local-data-to-update-an-arcgis-online-feature-service",
    "title": "Using arcgis with arcgisbinding",
    "section": "Use local data to update an ArcGIS Online feature service",
    "text": "Use local data to update an ArcGIS Online feature service\nImagine that you are in charge of maintaining a feature service for your organization that needs to be updated on a regular basis. To avoid dealing with tedious and error-prone manual updates, you can use a scheduled R script to make these updates automatically.\nIn this example, the user maintains an ArcGIS Online feature service containing data representing fatal car accidents in Missouri. Periodically, the user receives data updates in a file geodatabase. The workflow below uses arcgisbinding to read the feature class into R and convert it to an sf object. Then, arcgis uses the sf object to add the new features to the feature service.\n\nlibrary(sf)\nlibrary(arcgis)\nlibrary(arcgisbinding)\narc.check_product()\n\nproduct: ArcGIS Pro (13.2.0.49743)\nlicense: Advanced\nversion: 1.0.1.306 \n\n# use arcgisbinding to read in feature class\nfcpath = \"C:\\\\Data\\\\FARS_update.gdb\\\\FARS_2021\"\nfc &lt;- arc.open(fcpath)\nfc\n\ndataset_type    : FeatureClass\npath            : C:\\Data\\FARS_update.gdb\\FARS_2021 \nfields          : OBJECTID, Shape, state, statename, st_case, \nfields          : peds, pernotmvit, ve_total, ve_forms, pvh_invl, \nfields          : persons, permvit, county, countyname, city, \nfields          : cityname, month, monthname, day, dayname, \n          ... Truncated ...\nextent          : xmin=-162.5944, ymin=17.96028, xmax=-65.65091, ymax=66.89788\ngeometry type   : Point\nWKT             : GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\"...\nWKID            : 4326 \n\n# use arcgisbinding to filter data to Missouri and convert to sf\nsqlquery &lt;- \"STATENAME = 'Missouri'\"\nfcdata &lt;- arc.select(fc, where_clause=sqlquery)\nsfdata &lt;- arc.data2sf(fcdata) # project to 3857\n\n# use arcgis to set token\ntoken &lt;- auth_binding()\nset_arc_token(token)\n\nIn this case, the token is set using the active portal in ArcGIS Pro (via {arcgisbinding}). Note that other authorization methods could be used here, such as auth_code() or auth_user().\n\n# use arcgis to access feature service\nfsurl &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/Fatal_Vehicle_Accidents_in_Missouri/FeatureServer/0\"\nflyr &lt;- arc_open(fsurl)\nflyr\n\n&lt;FeatureLayer&gt;\nName: Missouri_Fatal_Accidents\nGeometry Type: esriGeometryPoint\nCRS: 3857\nCapabilities: Query\nAccess to this feature service is restricted (i.e., it is not shared to “Everyone” in ArcGIS Online). Because the user that requested the token does have access to read and modify this feature service, they are able to access the feature service and its metadata, as well as make changes to the data. Learn more about how access to items is managed in ArcGIS Online here.\n\n# use sf to project new data to the same crs as flyr\nsfdataprj &lt;- st_transform(sfdata, st_crs(flyr))\n\n# use arcgis to add the new features\nadd_res &lt;- add_features(flyr, sfdataprj)\ntail(add_res)\n\n    objectId uniqueId globalId success\n926     9287     9287       NA    TRUE\n927     9288     9288       NA    TRUE\n928     9289     9289       NA    TRUE\n929     9290     9290       NA    TRUE\n930     9291     9291       NA    TRUE\n931     9292     9292       NA    TRUE\nThe result of the add_features() function provides fine-grained information about the success (or failure) of the feature additions. Here, all 931 new features were successfully added to the feature service. If you were running this process as an automated script, you may want to capture and log any features that failed."
  },
  {
    "objectID": "location-services/overview.html",
    "href": "location-services/overview.html",
    "title": "Overview",
    "section": "",
    "text": "The arcgis package for location services meets developers where they are at. At its core, arcgis is a collection of R packages designed to interact with ArcGIS location services from the comfort of R and your development environment of choice.\nArcGIS location services are provided as REST API endpoints and arcgis makes interacting with the services using R native objects seamless.\nInstalling and loading the arcgis meta-package provides access to all of the associated packages and functionality:\n\ninstall.packages(\"arcgis\") # or pak::pak(\"r-arcgis/arcgis\")\nlibrary(arcgis)\n\n\n\n\n\n\n\n\nWorkflows\n\nExplore the core functions.\n\n\n\n\n  \n    \n      \n        Read hosted data\n      \n        \n        Bring geometries and attributes into R\n\n    \n    \n      \n    \n\n    \n\n  \n\n  \n    \n      \n        Authorize with your Portal\n      \n        \n        Log in using your ArcGIS Online or Enterprise credentials\n\n    \n    \n      \n    \n\n    \n\n  \n\n  \n    \n      \n        Publishing from R\n      \n        \n        Make data services accessible online\n\n    \n    \n      \n    \n\n    \n\n  \n\n  \n    \n      \n        Editing Features\n      \n        \n        Add, delete, and update features in a data service\n\n    \n    \n      \n    \n\n    \n\n  \n\n  \n    \n      \n        Overwrite Hosted Feature Layer\n      \n        \n        Replace the features populating a data service\n\n    \n    \n      \n    \n\n    \n\n  \n\n  \n    \n      \n        Using arcgis with arcgisbinding\n      \n        \n        Create workflows that use multiple R-ArcGIS Bridge packages\n\n    \n    \n      \n    \n\n    \n\n  \n\n\n\nTutorials\n\nFollow along to learn about advanced uses.\n\n\n\n\n  \n    \n      \n        Dashboard using {arcgis}\n      \n        \n        Build a dashboard using ArcGIS hosted data\n\n    \n    \n      \n    \n\n    \n\n  \n\n\n\nFrom the Community\n\nSee how others are using the package!\n\n\n\n\n  \n    \n      \n        NDVI Mapping with {arcgis}\n      \n        \n        by Milos Popovic\n\n    \n    \n      \n    \n\n    \n\n  \n\n  \n    \n      \n        Integration Examples using {arcgis}\n      \n        \n        by Diego Gabriel Miguel Vázquez\n\n    \n    \n      \n    \n\n    \n\n  \n\n\n\n\nNo matching items"
  },
  {
    "objectID": "location-services/publishing.html",
    "href": "location-services/publishing.html",
    "title": "Publishing from R",
    "section": "",
    "text": "In addition to consuming data as an R user, you may also want to publish data as a hosted feature service. In this tutorial, you will learn how to publish an sf object  to ArcGIS Online or Enterprise."
  },
  {
    "objectID": "location-services/publishing.html#authorization",
    "href": "location-services/publishing.html#authorization",
    "title": "Publishing from R",
    "section": "Authorization",
    "text": "Authorization\nIn order to publish content to ArcGIS Online or Enterprise, you must first obtain an access token permitting you to do so.\n\n\n\n\n\n\nCaution\n\n\n\nIf you have not yet set up your R environment for authorization, see Authorize with your Portal. Ensure that the environment variables ARCGIS_CLIENT and ARCGIS_USER are set at minimum. If you are using ArcGIS Enterprise, ensure that ARCGIS_HOST is properly set as well.\n\n\nGo through the following code flow to set your credentials.\n\nlibrary(arcgis)\n\n1token &lt;- auth_code()\n2set_arc_token(token)\n#&gt; Token set to environment variable `ARCGIS_TOKEN`\n\n\n1\n\nCreate an access token\n\n2\n\nSet it to an environment variable.\n\n\n\n\nNow that you have authorized to your Portal, you will be able to publish content."
  },
  {
    "objectID": "location-services/publishing.html#publishing-sf-objects",
    "href": "location-services/publishing.html#publishing-sf-objects",
    "title": "Publishing from R",
    "section": "Publishing {sf} objects",
    "text": "Publishing {sf} objects\nTo publish an {sf} object to your portal, you can use the function publish_layer(). The publishing process requires you to add an item to your portal and publish it. The publish_layer() function handles these steps for you.\nFirst, read in the North Carolina SIDS dataset that comes packaged with sf and store it in an object called nc.\n\nnc &lt;- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nNow that you have an sf object and you have authorized with your portal, all that’s left is to publish the item!\npublish_layer() has only two required arguments:\n\nx the sf object or data.frame\ntitle the title of layer you are creating\n\n\nres &lt;- publish_layer(nc, \"North Carolina SIDS\")\nres\n#&gt; $services\n#&gt;              type\n#&gt; 1 Feature Service\n#&gt;                                                                                             serviceurl\n#&gt; 1 https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North Carolina SIDS/FeatureServer\n#&gt;     size                                jobId                    serviceItemId\n#&gt; 1 125766 f14451a7-325b-40b0-85c3-534bcf122806 32511ce0413f40d08303e267a7093be0\n#&gt;                                                                                          encodedServiceURL\n#&gt; 1 https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer\n\n\n\n\n\n\n\nWarning\n\n\n\nIf you encounter errors while publishing, try using a feature layer title that does not contain spaces or special characters, such as “NorthCarolinaSIDS” for this example.\n\n\nNow from your Portal’s Content page you should see two items associated with your feature service:\n\nBehind the scenes, publish_layer() added the sf object as a Feature Layer item first and then published this item as a Feature Layer (hosted). After publishing, you will typically only interact with the hosted feature layer. (Note that the dependency between these two items prevents you from deleting the underlying feature layer while the hosted feature layer still exists.)\n\n\nLearn about hosted feature layers\nClick View details on the hosted feature layer item and you should see something like the below:"
  },
  {
    "objectID": "location-services/publishing.html#reading-the-published-feature-layer",
    "href": "location-services/publishing.html#reading-the-published-feature-layer",
    "title": "Publishing from R",
    "section": "Reading the published Feature Layer",
    "text": "Reading the published Feature Layer\nThe output of the publish_layer() function is a list that contains information about where the sf object was published. You can retrieve the encodedServiceUrl from the response and use arc_open() to return the metadata for your newly-created service.\n\nnc_fserver &lt;- arc_open(res[[c(\"services\", \"encodedServiceURL\")]])\nnc_fserver\n#&gt; &lt;FeatureServer &lt;1 layer, 0 tables&gt;&gt;\n#&gt; CRS: 4267\n#&gt; Capabilities: Create,Delete,Query,Update,Editing\n#&gt;   0: North Carolina SIDS (esriGeometryPolygon)\n\nYou’ll notice that this is a FeatureServer. All items that are published to a Portal become their own Feature Server with a single FeatureLayer.\nYou can extract a single layer from the FeatureServer using get_layer(). Provide the FeatureServer as the first argument and then the ID of the layer you want as the second argument.\n\nget_layer(nc_fserver, 0)\n#&gt; &lt;FeatureLayer&gt;\n#&gt; Name: North Carolina SIDS\n#&gt; Geometry Type: esriGeometryPolygon\n#&gt; CRS: 4267\n#&gt; Capabilities: Create,Delete,Query,Update,Editing"
  },
  {
    "objectID": "location-services/publishing.html#publishing-data.frames",
    "href": "location-services/publishing.html#publishing-data.frames",
    "title": "Publishing from R",
    "section": "Publishing data.frames",
    "text": "Publishing data.frames\nPublishing a data.frame follows the same steps as those above. The difference is that it creates a Table object. Try repeating the same process but using the palmerpenguins dataset!\n\n# install.packages(\"palmerpenguins\")\npalmerpenguins::penguins\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npublish_layer(palmerpenguins::penguins, \"Palmer Penguins\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R-ArcGIS Bridge",
    "section": "",
    "text": "The R-ArcGIS Bridge is a collection of R packages designed to integrate the R language with the ArcGIS Ecosystem. The R-ArcGIS Bridge can be used to:\n\nCreate R-based geoprocessing tools\nAccess and publish data on ArcGIS Online, Enterprise, or Platform\nGeocode addresses at scale\nAccess detailed point of interest (POI) data\n\n\n\n\nDiscover key features of the R-ArcGIS Bridge\nInstall the R packages\nExplore tutorials sample code",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#where-to-start",
    "href": "index.html#where-to-start",
    "title": "R-ArcGIS Bridge",
    "section": "",
    "text": "Discover key features of the R-ArcGIS Bridge\nInstall the R packages\nExplore tutorials sample code",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "docs/geocode/reverse-geocoding.html",
    "href": "docs/geocode/reverse-geocoding.html",
    "title": "Reverse Geocoding",
    "section": "",
    "text": "Often you may coordinates of locations but need their addresses as well. Reverse geocoding finds an address associated with a location on earth.\nUse arcgisgeocode::reverse_geocode() to perform reverse geocoding. Using this fuction you can\n\nreverse geocode an sfc_POINT geometry column from the {sf} package\nreverse geocode a matrix of coordinates\nreverse geocode a single location as a length 2 vector e.g. c(-117, 34)\n\n\nReverse geocode a single point\nFirst, load the R package.\n\nlibrary(arcgisgeocode)\n\nYou can reverse geocode a single longitude/latitude pair as a length 2 vector with reverse_geocode().\n\n# Find addresses from locations\nres &lt;- reverse_geocode(c(-117.172, 34.052))\ndplyr::glimpse(res)\n\nRows: 1\nColumns: 23\n$ match_addr   &lt;chr&gt; \"600-620 Home Pl, Redlands, California, 92374\"\n$ long_label   &lt;chr&gt; \"600-620 Home Pl, Redlands, CA, 92374, USA\"\n$ short_label  &lt;chr&gt; \"600-620 Home Pl\"\n$ addr_type    &lt;chr&gt; \"StreetAddress\"\n$ type_field   &lt;chr&gt; \"\"\n$ place_name   &lt;chr&gt; \"\"\n$ add_num      &lt;chr&gt; \"608\"\n$ address      &lt;chr&gt; \"608 Home Pl\"\n$ block        &lt;chr&gt; \"\"\n$ sector       &lt;chr&gt; \"\"\n$ neighborhood &lt;chr&gt; \"South Redlands\"\n$ district     &lt;chr&gt; \"\"\n$ city         &lt;chr&gt; \"Redlands\"\n$ metro_area   &lt;chr&gt; \"\"\n$ subregion    &lt;chr&gt; \"San Bernardino County\"\n$ region       &lt;chr&gt; \"California\"\n$ region_abbr  &lt;chr&gt; \"CA\"\n$ territory    &lt;chr&gt; \"\"\n$ postal       &lt;chr&gt; \"92374\"\n$ postal_ext   &lt;chr&gt; \"\"\n$ country_name &lt;chr&gt; \"United States\"\n$ country_code &lt;chr&gt; \"USA\"\n$ geometry     &lt;POINT [°]&gt; POINT (-117.172 34.05204)\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIt is important to note that when you are not using an sfc_POINT object, the coordinate reference system is not known. So it is assumed to be EPSG:4326. If you provide values outside of [-180, 180] and [-90, 90] for longitude or latitude, an error will occur.\n\n\n\n\nReverse geocode from an sf object\nMore commonly, you may have an sf object that you want to reverse geocode their locations. To demonstrate this, you will reverse geocode a csv of state capitals.\nFirst, read the csv file into a data.frame and convert it to an sf object.\n\nlibrary(sf)\nlibrary(dplyr)\n\n# USA State Capitals\nfp &lt;- \"https://analysis-1.maps.arcgis.com/sharing/rest/content/items/85bcfca158d641b99e7579b47cfee91e/data\"\n\n# read the csv\ncapitals &lt;- readr::read_csv(fp) |&gt;\n  # convert to an sf object with EPSG:4326\n  st_as_sf(\n    coords = c(\"longitude\", \"latitude\"),\n    crs = 4326\n  )\n\ncapitals\n\nSimple feature collection with 50 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -157.8574 ymin: 21.30744 xmax: -69.78169 ymax: 58.3016\nGeodetic CRS:  WGS 84\n# A tibble: 50 × 3\n   name        description              geometry\n * &lt;chr&gt;       &lt;chr&gt;                 &lt;POINT [°]&gt;\n 1 Alabama     Montgomery   (-86.30057 32.37772)\n 2 Alaska      Juneau        (-134.4202 58.3016)\n 3 Arizona     Phoenix       (-112.097 33.44814)\n 4 Arkansas    Little Rock  (-92.28899 34.74661)\n 5 California  Sacramento   (-121.4936 38.57667)\n 6 Colorado    Denver       (-104.9849 39.73923)\n 7 Connecticut Hartford&lt;br&gt;  (-72.6822 41.76405)\n 8 Delaware    Dover        (-75.51972 39.15731)\n 9 Hawaii      Honolulu     (-157.8574 21.30744)\n10 Florida     Tallahassee   (-84.2813 30.43812)\n# ℹ 40 more rows\n\n\nUse reverse_geocode() with the geometry column from the capitals to create a new sf object with the address information.\n\ngeocoded &lt;- reverse_geocode(st_geometry(capitals))\nglimpse(geocoded)\n\nRows: 50\nColumns: 23\n$ match_addr   &lt;chr&gt; \"Alabama State Capitol\", \"Juneau Post Office - Federal St…\n$ long_label   &lt;chr&gt; \"Alabama State Capitol, Montgomery, AL, USA\", \"Juneau Pos…\n$ short_label  &lt;chr&gt; \"Alabama State Capitol\", \"Juneau Post Office - Federal St…\n$ addr_type    &lt;chr&gt; \"POI\", \"POI\", \"POI\", \"POI\", \"POI\", \"POI\", \"POI\", \"POI\", \"…\n$ type_field   &lt;chr&gt; \"Building\", \"Post Office\", \"Museum\", \"Government Office\",…\n$ place_name   &lt;chr&gt; \"Alabama State Capitol\", \"Juneau Post Office - Federal St…\n$ add_num      &lt;chr&gt; \"\", \"\", \"1700\", \"500\", \"1315\", \"101\", \"210\", \"411\", \"304\"…\n$ address      &lt;chr&gt; \"\", \"\", \"1700 W Washington St\", \"500 Woodlane Ave\", \"1315…\n$ block        &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ sector       &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ neighborhood &lt;chr&gt; \"\", \"\", \"Central City\", \"\", \"Downtown Sacramento\", \"\", \"D…\n$ district     &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ city         &lt;chr&gt; \"Montgomery\", \"Juneau\", \"Phoenix\", \"Little Rock\", \"Sacram…\n$ metro_area   &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ subregion    &lt;chr&gt; \"Montgomery County\", \"Juneau City and Borough\", \"Maricopa…\n$ region       &lt;chr&gt; \"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\", \"California\",…\n$ region_abbr  &lt;chr&gt; \"AL\", \"AK\", \"AZ\", \"AR\", \"CA\", \"CO\", \"CT\", \"DE\", \"HI\", \"FL…\n$ territory    &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ postal       &lt;chr&gt; \"\", \"\", \"85007\", \"72201\", \"95814\", \"80203\", \"06105\", \"199…\n$ postal_ext   &lt;chr&gt; \"\", \"\", \"\", \"\", \"4801\", \"\", \"\", \"\", \"2420\", \"\", \"\", \"\", \"…\n$ country_name &lt;chr&gt; \"United States\", \"United States\", \"United States\", \"Unite…\n$ country_code &lt;chr&gt; \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"…\n$ geometry     &lt;POINT [°]&gt; POINT (-86.30049 32.37775), POINT (-134.4203 58.301…\n\n\nThen, you can use dplyr (or base R via cbind()) to combine the two datasets. In this example, the geometry column from the reverse geocoding results is drops. This prevents dplyr from renaming the duplicate columns and preserves the sf class.\n\nbind_cols(\n  capitals,\n  st_drop_geometry(geocoded)\n)\n\nSimple feature collection with 50 features and 24 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -157.8574 ymin: 21.30744 xmax: -69.78169 ymax: 58.3016\nGeodetic CRS:  WGS 84\n# A tibble: 50 × 25\n   name  description             geometry match_addr      long_label short_label\n * &lt;chr&gt; &lt;chr&gt;                &lt;POINT [°]&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;      \n 1 Alab… Montgomery  (-86.30057 32.37772) Alabama State … Alabama S… Alabama St…\n 2 Alas… Juneau       (-134.4202 58.3016) Juneau Post Of… Juneau Po… Juneau Pos…\n 3 Ariz… Phoenix      (-112.097 33.44814) Arizona Capito… Arizona C… Arizona Ca…\n 4 Arka… Little Rock (-92.28899 34.74661) Arkansas State… Arkansas … Arkansas S…\n 5 Cali… Sacramento  (-121.4936 38.57667) California Sta… Californi… California…\n 6 Colo… Denver      (-104.9849 39.73923) Credit Repair   Credit Re… Credit Rep…\n 7 Conn… Hartford&lt;b…  (-72.6822 41.76405) Connecticut St… Connectic… Connecticu…\n 8 Dela… Dover       (-75.51972 39.15731) Delaware Senat… Delaware … Delaware S…\n 9 Hawa… Honolulu    (-157.8574 21.30744) Eternal Flame … Eternal F… Eternal Fl…\n10 Flor… Tallahassee  (-84.2813 30.43812) Florida Capito… Florida C… Florida Ca…\n# ℹ 40 more rows\n# ℹ 19 more variables: addr_type &lt;chr&gt;, type_field &lt;chr&gt;, place_name &lt;chr&gt;,\n#   add_num &lt;chr&gt;, address &lt;chr&gt;, block &lt;chr&gt;, sector &lt;chr&gt;,\n#   neighborhood &lt;chr&gt;, district &lt;chr&gt;, city &lt;chr&gt;, metro_area &lt;chr&gt;,\n#   subregion &lt;chr&gt;, region &lt;chr&gt;, region_abbr &lt;chr&gt;, territory &lt;chr&gt;,\n#   postal &lt;chr&gt;, postal_ext &lt;chr&gt;, country_name &lt;chr&gt;, country_code &lt;chr&gt;\n\n\nAlternatively, you can accomplish this using a more esoteric and tidyverse-centric approach. The below is an option that uses mutate() to create a new column which is an sf object. Then, it uses tidyr::unnest() to unnest the newly created sf column.\n\ncapitals |&gt;\n  mutate(\n    address_info = st_drop_geometry(\n      reverse_geocode(geometry)\n    )\n  ) |&gt;\n  tidyr::unnest(address_info)\n\nSimple feature collection with 50 features and 24 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -157.8574 ymin: 21.30744 xmax: -69.78169 ymax: 58.3016\nGeodetic CRS:  WGS 84\n# A tibble: 50 × 25\n   name  description             geometry match_addr      long_label short_label\n   &lt;chr&gt; &lt;chr&gt;                &lt;POINT [°]&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;      \n 1 Alab… Montgomery  (-86.30057 32.37772) Alabama State … Alabama S… Alabama St…\n 2 Alas… Juneau       (-134.4202 58.3016) Juneau Post Of… Juneau Po… Juneau Pos…\n 3 Ariz… Phoenix      (-112.097 33.44814) Arizona Capito… Arizona C… Arizona Ca…\n 4 Arka… Little Rock (-92.28899 34.74661) Arkansas State… Arkansas … Arkansas S…\n 5 Cali… Sacramento  (-121.4936 38.57667) California Sta… Californi… California…\n 6 Colo… Denver      (-104.9849 39.73923) Credit Repair   Credit Re… Credit Rep…\n 7 Conn… Hartford&lt;b…  (-72.6822 41.76405) Connecticut St… Connectic… Connecticu…\n 8 Dela… Dover       (-75.51972 39.15731) Delaware Senat… Delaware … Delaware S…\n 9 Hawa… Honolulu    (-157.8574 21.30744) Eternal Flame … Eternal F… Eternal Fl…\n10 Flor… Tallahassee  (-84.2813 30.43812) Florida Capito… Florida C… Florida Ca…\n# ℹ 40 more rows\n# ℹ 19 more variables: addr_type &lt;chr&gt;, type_field &lt;chr&gt;, place_name &lt;chr&gt;,\n#   add_num &lt;chr&gt;, address &lt;chr&gt;, block &lt;chr&gt;, sector &lt;chr&gt;,\n#   neighborhood &lt;chr&gt;, district &lt;chr&gt;, city &lt;chr&gt;, metro_area &lt;chr&gt;,\n#   subregion &lt;chr&gt;, region &lt;chr&gt;, region_abbr &lt;chr&gt;, territory &lt;chr&gt;,\n#   postal &lt;chr&gt;, postal_ext &lt;chr&gt;, country_name &lt;chr&gt;, country_code &lt;chr&gt;\n\n\n\n\nReverse geocoding a matrix of coordinates\nThere are other times where you may have your coordinates stored as a matrix with two columns. reverse_geocode() accepts a 2 column numeric matrix as an input to its location argument.\nFor the sake of example, the coordinates are extracted as a matrix using sf::st_coordinates().\n\ncoords &lt;- st_coordinates(capitals)\nhead(coords)\n\n              X        Y\n[1,]  -86.30057 32.37772\n[2,] -134.42021 58.30160\n[3,] -112.09696 33.44814\n[4,]  -92.28899 34.74661\n[5,] -121.49363 38.57667\n[6,] -104.98486 39.73923\n\n\nPass this matrix directly into reverse_geocode().\n\ngeocoded &lt;- reverse_geocode(coords)\nglimpse(geocoded)\n\nRows: 50\nColumns: 23\n$ match_addr   &lt;chr&gt; \"Alabama State Capitol\", \"Juneau Post Office - Federal St…\n$ long_label   &lt;chr&gt; \"Alabama State Capitol, Montgomery, AL, USA\", \"Juneau Pos…\n$ short_label  &lt;chr&gt; \"Alabama State Capitol\", \"Juneau Post Office - Federal St…\n$ addr_type    &lt;chr&gt; \"POI\", \"POI\", \"POI\", \"POI\", \"POI\", \"POI\", \"POI\", \"POI\", \"…\n$ type_field   &lt;chr&gt; \"Building\", \"Post Office\", \"Museum\", \"Government Office\",…\n$ place_name   &lt;chr&gt; \"Alabama State Capitol\", \"Juneau Post Office - Federal St…\n$ add_num      &lt;chr&gt; \"\", \"\", \"1700\", \"500\", \"1315\", \"101\", \"210\", \"411\", \"304\"…\n$ address      &lt;chr&gt; \"\", \"\", \"1700 W Washington St\", \"500 Woodlane Ave\", \"1315…\n$ block        &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ sector       &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ neighborhood &lt;chr&gt; \"\", \"\", \"Central City\", \"\", \"Downtown Sacramento\", \"\", \"D…\n$ district     &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ city         &lt;chr&gt; \"Montgomery\", \"Juneau\", \"Phoenix\", \"Little Rock\", \"Sacram…\n$ metro_area   &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ subregion    &lt;chr&gt; \"Montgomery County\", \"Juneau City and Borough\", \"Maricopa…\n$ region       &lt;chr&gt; \"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\", \"California\",…\n$ region_abbr  &lt;chr&gt; \"AL\", \"AK\", \"AZ\", \"AR\", \"CA\", \"CO\", \"CT\", \"DE\", \"HI\", \"FL…\n$ territory    &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n$ postal       &lt;chr&gt; \"\", \"\", \"85007\", \"72201\", \"95814\", \"80203\", \"06105\", \"199…\n$ postal_ext   &lt;chr&gt; \"\", \"\", \"\", \"\", \"4801\", \"\", \"\", \"\", \"2420\", \"\", \"\", \"\", \"…\n$ country_name &lt;chr&gt; \"United States\", \"United States\", \"United States\", \"Unite…\n$ country_code &lt;chr&gt; \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"…\n$ geometry     &lt;POINT [°]&gt; POINT (-86.30049 32.37775), POINT (-134.4203 58.301…",
    "crumbs": [
      "Geocoding",
      "Reverse Geocoding"
    ]
  },
  {
    "objectID": "docs/geocode/overview.html",
    "href": "docs/geocode/overview.html",
    "title": "Overview",
    "section": "",
    "text": "Addresses represent a physical place. They’re meant to be interpreted by people and help guide navigation of the built environment. Addresses represent a geographical place but lack geographic data.\nThe package {arcgisgeocode} enables you to search for an address (geocode), reverse geocode, find candidate matches, get suggestions, and batch geocode. Geocoding is the process of converting text to an address and a location.",
    "crumbs": [
      "Geocoding",
      "Overview"
    ]
  },
  {
    "objectID": "docs/geocode/overview.html#geocode-an-address",
    "href": "docs/geocode/overview.html#geocode-an-address",
    "title": "Overview",
    "section": "Geocode an address",
    "text": "Geocode an address\nPerform single address geocoding using the find_address_candidates() function. Limit the number of results using the max_locations argument.\n\nloc &lt;- find_address_candidates(\n    \"501 Edgewood Ave SE, Atlanta, GA 30312\", max_locations = 1\n)\n\nloc[, 1:8]\n\nSimple feature collection with 1 feature and 8 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -84.37108 ymin: 33.75396 xmax: -84.37108 ymax: 33.75396\nGeodetic CRS:  WGS 84\n  input_id result_id loc_name status score\n1        1        NA    World      M   100\n                                    match_addr\n1 501 Edgewood Ave SE, Atlanta, Georgia, 30312\n                                    long_label         short_label\n1 501 Edgewood Ave SE, Atlanta, GA, 30312, USA 501 Edgewood Ave SE\n                    geometry\n1 POINT (-84.37108 33.75396)",
    "crumbs": [
      "Geocoding",
      "Overview"
    ]
  },
  {
    "objectID": "docs/geocode/overview.html#reverse-geocode",
    "href": "docs/geocode/overview.html#reverse-geocode",
    "title": "Overview",
    "section": "Reverse geocode",
    "text": "Reverse geocode\nFrom a location, find its corresponding address using reverse_geocode().\n\nreverse_geocode(c(-84.371, 33.753))\n\nRegistered S3 method overwritten by 'jsonify':\n  method     from    \n  print.json jsonlite\n\n\nSimple feature collection with 1 feature and 22 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -84.37103 ymin: 33.75322 xmax: -84.37103 ymax: 33.75322\nGeodetic CRS:  WGS 84\n                                match_addr\n1 39 Daniel St SE, Atlanta, Georgia, 30312\n                                long_label     short_label    addr_type\n1 39 Daniel St SE, Atlanta, GA, 30312, USA 39 Daniel St SE PointAddress\n  type_field place_name add_num         address block sector neighborhood\n1                            39 39 Daniel St SE                          \n  district    city metro_area     subregion  region region_abbr territory\n1          Atlanta            Fulton County Georgia          GA          \n  postal postal_ext  country_name country_code                   geometry\n1  30312       1907 United States          USA POINT (-84.37103 33.75322)",
    "crumbs": [
      "Geocoding",
      "Overview"
    ]
  },
  {
    "objectID": "docs/editing/delete-features.html",
    "href": "docs/editing/delete-features.html",
    "title": "Deleting features",
    "section": "",
    "text": "While add_features() and update_features() had a very similar syntax, delete_features() has a somewhat different interface. We have 3 different ways in which we can delete features. Here we will explore only two of them.\n\nlibrary(arcgis)\nset_arc_token(auth_code())\n\nnc_url &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\" \n\nnc &lt;- arc_open(nc_url)\n\nWe can delete features based on object IDs or a SQL where clause. Let’s explore deleting features based on object IDs. To do so, we need to pass the FeatureLayer obejct as the first argument to delete_features(). The second argument is a numeric vector of the IDs we want to delete. The ID 101 is the new feature that we created.\n\ndelete_res &lt;- delete_features(nc, object_ids = 101)\ndelete_res\n\n$deleteResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\nWe can check to see if the delete worked by refreshing the layer and seeing the count that is printed out.\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nAlternatively, we can delete features based on a where clause. Say we wanted to delete all of the features where the BIR74 value was less than 1000. We can accomplish this using a where clause.\n\ndelete_res &lt;- delete_features(nc, where = \"BIR74 &lt; 1000\")\ndelete_res\n\n$deleteResults\n   objectId uniqueId globalId success\n1         2        2       NA    TRUE\n2         4        4       NA    TRUE\n3         7        7       NA    TRUE\n4         8        8       NA    TRUE\n5         9        9       NA    TRUE\n6        20       20       NA    TRUE\n7        21       21       NA    TRUE\n8        22       22       NA    TRUE\n9        32       32       NA    TRUE\n10       35       35       NA    TRUE\n11       38       38       NA    TRUE\n12       44       44       NA    TRUE\n13       45       45       NA    TRUE\n14       56       56       NA    TRUE\n15       58       58       NA    TRUE\n16       59       59       NA    TRUE\n17       73       73       NA    TRUE\n18       77       77       NA    TRUE\n19       78       78       NA    TRUE\n20       80       80       NA    TRUE\n21       83       83       NA    TRUE\n22       87       87       NA    TRUE\n23       90       90       NA    TRUE\nSuccessful deletes! Again, we can check to see the new count using refresh_layer().\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nLastly, if you want to delete every single feature. We can take advantage of the where clause again. If we set where = \"1 = 1\" that will evaluate TRUE for every single feature.\n\ndelete_res &lt;- delete_features(nc, where = \"1 = 1\")\ndelete_res\n\n$deleteResults\n   objectId uniqueId globalId success\n1         1        1       NA    TRUE\n2         3        3       NA    TRUE\n3         5        5       NA    TRUE\n4         6        6       NA    TRUE\n5        10       10       NA    TRUE\n6        11       11       NA    TRUE\n          ... Truncated ...\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nNote that you shuold use truncate_layer() instead of delete_features(x, where = \"1 = 1\").",
    "crumbs": [
      "Editing",
      "Deleting features"
    ]
  },
  {
    "objectID": "docs/editing/add-features.html",
    "href": "docs/editing/add-features.html",
    "title": "Adding features",
    "section": "",
    "text": "Programmatically, adding, deleting, or updating features using {arcgis} is a straightforward process. In this workflow, we illustrate how to add, update, or delete features from an existing hosted feature layer or table.\nWe will go over the functions:",
    "crumbs": [
      "Editing",
      "Adding features"
    ]
  },
  {
    "objectID": "docs/editing/add-features.html#pre-requisites",
    "href": "docs/editing/add-features.html#pre-requisites",
    "title": "Adding features",
    "section": "Pre-requisites",
    "text": "Pre-requisites\nWe will use the the North Carolina SIDS dataset we created in the Publishing from R tutorial. To follow along, be sure that you have followed that tutorial and have a FeatureLayer that you can modify. If you have not yet configured your environment to authorize with an online portal, start at Connecting to your portal.",
    "crumbs": [
      "Editing",
      "Adding features"
    ]
  },
  {
    "objectID": "docs/editing/add-features.html#adding-features",
    "href": "docs/editing/add-features.html#adding-features",
    "title": "Adding features",
    "section": "Adding features",
    "text": "Adding features\nFor this example, we will add a single feature to the North Carolina SIDS dataset that is a summary over the entire state. Before we can begin, we must load the package and authorize ourselves as a user.\n\nlibrary(arcgis)\n\ntoken &lt;- auth_code()\nset_auth_token(token)\n\nNext, we will create the feature that we want to add using the sf package. We’ll read in the nc.shp file from the sf package.\n\nlibrary(sf)\nnc_sf &lt;- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc_sf\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nLet’s calculate the average birth rate, SIDS rate, and the non-white birth rate and SIDS rate for the entire state. We will add this as a single feature to our existing feature layer. To do so, we will use the R package dplyr for manipulating our data.\n\nlibrary(dplyr)\n\nnc_summary &lt;- nc_sf |&gt;  \n  summarise(\n1    across(\n2      .cols = c(ends_with(\"74\"), ends_with(\"79\")),\n3      .fns = mean\n    ),\n4    NAME = \"Total\"\n  ) \n\nnc_summary\n\n\n1\n\nThe across() function applies a function to multiple columns at once.\n\n2\n\nWe specify the columns we will be applying a function to in .cols. We use the tidyselect helpers to catch any columns that end with 74 or 79.\n\n3\n\nThe .fns argument specifies which functions will be applied to the columns. In this case, we apply on the mean() function to calculate the average.\n\n4\n\nThe NAME field is set manually to the value of \"Total\" to indicate that it is not a county.\n\n\n\n\nSimple feature collection with 1 feature and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 1 × 8\n  BIR74 SID74 NWBIR74 BIR79 SID79 NWBIR79 NAME                          geometry\n  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;               &lt;MULTIPOLYGON [°]&gt;\n1 3300.  6.67   1051. 4224.  8.36   1353. Total (((-75.97629 36.51793, -75.9772…\n\n\nIn order to add this new aggregate feature to the FeatureLayer we must create a reference to the layer using arc_open().\n\nnc_url &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\" \n\nnc &lt;- arc_open(nc_url)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n\n\n\n\n\n\nNote\n\n\n\nThe url you use here will be different than the one you see. Be sure to grab the correct url from the content listing for your item.\n\n\nNow that we have a FeatureLayer object we can add features to it using add_features(). There are a few key arguments to the function:\n\nx is the FeatureLayer object that we want to add features to\n.data is an sf object that we want to add to the FeatureLayer\nmatch_on determines how to match sf columns to FeatureLayer fields\n\nBy default, add_features() will compare the column names of the sf object to that of the FeatureLayer. We can find the field names and aliases for a FeatureLayer by using the list_fields() function. Pass the results to tibble::as_tibble() to make them more readable.\nSince we know that the column names match those of the FeatureLayer, we can pass nc_summary directly to add_feature().\n\nadd_res &lt;- add_features(nc, nc_summary)\nadd_res\n\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\n\n\n\n\n\n\nTip\n\n\n\nIf you are adding many features at one time, consider changing the value of chunk_size. By default, add_features() will add up to 2000 features at a time and send the requests in parallel. Depending on the geometry type and precision, it may be worthwhile to make that number smaller. If the data are truly massive, consider breaking up the task into smaller manageable chunks.\n\n\nOnce we’ve added the results to the FeatureLayer, we may want to refresh the object to catch any important changes to the metadata.\n\nnc &lt;- refresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nWe can see that the FeatureLayer now has 101 features as opposed to the original 100. To sanity check, we can query nc to see how the value comes back.\n\nnc_avgs &lt;- nc |&gt; \n  filter(NAME == \"Total\") |&gt; \n  collect()\n\nnc_avgs\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101   NA        NA    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...",
    "crumbs": [
      "Editing",
      "Adding features"
    ]
  },
  {
    "objectID": "docs/layers/read-layers.html",
    "href": "docs/layers/read-layers.html",
    "title": "Reading Feature Services",
    "section": "",
    "text": "ArcGIS Online and Enterprise web services can easily be read into R using{arcgislayers}. Supported service types include:\nMetadata for all of the above service types can be accessed using arc_open(). Feature data can be read in using arc_select() for FeatureLayer, Table, and ImageServer.\nThis tutorial will teach you the basics of reading data from hosted Feature Layers into R as {sf} objects using{arcgislayers}.",
    "crumbs": [
      "Layers",
      "Reading Feature Services"
    ]
  },
  {
    "objectID": "docs/layers/read-layers.html#objective",
    "href": "docs/layers/read-layers.html#objective",
    "title": "Reading Feature Services",
    "section": "Objective",
    "text": "Objective\nThe objective of this tutorial is to teach you how to:\n\nfind a Feature Layer url from ArcGIS Online\nread in the data from the Feature Layer\nselect the Feature Layer data by column\nfilter the Feature Layer data by attributes\nuse dplyr for selecting and filtering",
    "crumbs": [
      "Layers",
      "Reading Feature Services"
    ]
  },
  {
    "objectID": "docs/layers/read-layers.html#obtaining-a-feature-layer-url",
    "href": "docs/layers/read-layers.html#obtaining-a-feature-layer-url",
    "title": "Reading Feature Services",
    "section": "Obtaining a feature layer url",
    "text": "Obtaining a feature layer url\nFor this example, you will read in population data of major US cities from ArcGIS Online.\nYou will use the functions arc_open() and arc_select() to read data from ArcGIS Online into R. However, these functions require the url of the hosted feature service. To find this, navigate to the item in ArcGIS Online.\n When you scroll down, on the right hand side, you will see a button to view the service itself.\n\nClicking this will bring you to the Feature Service. Inside of a Feature Server there may be many layers or tables that you can use. In this case, there is only one layer. Click the hyperlinked USA Major Cities.\n\nThis reveals the Feature Layer of interest.\n\nNavigate to your browser’s search bar and copy the url.\nhttps://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Major_Cities_/FeatureServer/0",
    "crumbs": [
      "Layers",
      "Reading Feature Services"
    ]
  },
  {
    "objectID": "docs/layers/read-layers.html#opening-a-feature-layer",
    "href": "docs/layers/read-layers.html#opening-a-feature-layer",
    "title": "Reading Feature Services",
    "section": "Opening a Feature Layer",
    "text": "Opening a Feature Layer\nBefore you can read in the Feature Layer, you need to load the arcgis R package. If you do not have arcgis installed, install it with pak::pak(\"r-arcgis/arcgis\") or install.packages(\"arcgis\").\n\n\n{pak} is an R package that makes it faster and easier to install R packages. If you do not have it installed, run install.packages(\"pak\") first.\n\nlibrary(arcgis)\n\nAttaching core arcgis packages:\n→ arcgisutils v0.3.0\n→ arcgislayers v0.2.0\n\n\nUse the below code to store the Feature Layer url in an object called furl (as in feature layer url).\n\nfurl &lt;- \"https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Major_Cities_/FeatureServer/0\"\n\nThen pass this variable to arc_open() and save it to flayer (feature layer).\n\nflayer &lt;- arc_open(furl)\nflayer\n\n&lt;FeatureLayer&gt;\nName: USA Major Cities\nGeometry Type: esriGeometryPoint\nCRS: 4326\nCapabilities: Query,Extract\n\n\narc_open() will create a FeatureLayer object. Under the hood, this is really just a list containing the feature layer’s metadata.\n\n\n\n\n\n\nFeatureLayer details for the curious\n\n\n\n\n\nThe FeatureLayer object is obtained by adding ?f=json to the feature layer url and processing the json. All of the metadata is stored in the FeatureLayer object. You can see this by running unclass(flayer). Be warned! It gets messy.\n\n\n\nWith this FeatureLayer object, you can read data from the service into R!",
    "crumbs": [
      "Layers",
      "Reading Feature Services"
    ]
  },
  {
    "objectID": "docs/layers/read-layers.html#reading-from-a-feature-layer",
    "href": "docs/layers/read-layers.html#reading-from-a-feature-layer",
    "title": "Reading Feature Services",
    "section": "Reading from a Feature Layer",
    "text": "Reading from a Feature Layer\nOnce you have a FeatureLayer object, you can read its data into memory using the arc_select() function. By default, if you use arc_select() on a FeatureLayer without any additional arguments, the entire service will be brought into memory.\n\n\n\n\n\n\nWarning\n\n\n\nAvoid reading in more data than you need! Reading an entire feature service is fine for datasets with fewer than 5,000 features. But when there are more than 10,000 features, performance and memory may be throttled.\nExceptionally detailed geometries require more data to be transferred across the web and may be slower to process and may require adjustment of the page_size argument of arc_select().\n\n\nStore the results of arc_select() in the object cities.\n\ncities &lt;- arc_select(flayer)\ncities\n\nSimple feature collection with 4186 features and 11 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -159.3191 ymin: 19.58272 xmax: -68.77234 ymax: 64.86928\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   OBJECTID           NAME CLASS STATE_ABBR STATE_FIPS PLACE_FIPS POPULATION\n1         1      Alabaster  city         AL         01    0100820      33284\n2         2    Albertville  city         AL         01    0100988      22386\n3         3 Alexander City  city         AL         01    0101132      14843\n4         4       Anniston  city         AL         01    0101852      21564\n5         5         Athens  city         AL         01    0102956      25406\n6         6         Atmore  city         AL         01    0103004       8391\n7         7         Auburn  city         AL         01    0103076      76143\n8         8       Bessemer  city         AL         01    0105980      26019\n9         9     Birmingham  city         AL         01    0107000     200733\n10       10         Calera  city         AL         01    0111416      16494\n   POP_CLASS POP_SQMI   SQMI CAPITAL                   geometry\n1          6   1300.7  25.59          POINT (-86.81782 33.2445)\n2          6    827.9  27.04         POINT (-86.21205 34.26421)\n3          6    337.4  43.99         POINT (-85.95631 32.94309)\n4          6    469.9  45.89          POINT (-85.81986 33.6565)\n5          6    625.8  40.60          POINT (-86.9508 34.78484)\n6          5    382.5  21.94         POINT (-87.49009 31.02226)\n7          7   1234.5  61.68         POINT (-85.48999 32.60691)\n8          6    641.8  40.54          POINT (-86.9563 33.40092)\n9          8   1342.2 149.55          POINT (-86.79647 33.5288)\n10         6    674.0  24.47          POINT (-86.74549 33.1244)\n\n\nThe result is an sf object that you can now work with using sf and any other R packages.\n\nSpecifying output fields\nIn some cases, you may have Feature Layers with many extraneous fields. You can specify which fields to return to R using the fields argument.\n\n\n\n\n\n\nTip\n\n\n\nRemember to only read in the data that you need. Adding unneeded fields uses more memory and takes longer to process.\n\n\nfields takes a character vector of field names. To see which fields are available in a Feature Layer, you can use the utility function list_fields().\n\nfields &lt;- list_fields(flayer)\nfields[, 1:4]\n\n         name                      type                  alias      sqlType\n1    OBJECTID          esriFieldTypeOID               OBJECTID sqlTypeOther\n2        NAME       esriFieldTypeString                   Name sqlTypeOther\n3       CLASS       esriFieldTypeString                  Class sqlTypeOther\n4  STATE_ABBR       esriFieldTypeString     State Abbreviation sqlTypeOther\n5  STATE_FIPS       esriFieldTypeString             State FIPS sqlTypeOther\n6  PLACE_FIPS       esriFieldTypeString             Place FIPS sqlTypeOther\n7  POPULATION      esriFieldTypeInteger  2020 Total Population sqlTypeOther\n8   POP_CLASS esriFieldTypeSmallInteger       Population Class sqlTypeOther\n9    POP_SQMI       esriFieldTypeDouble People per square mile sqlTypeOther\n10       SQMI       esriFieldTypeDouble   Area in square miles sqlTypeOther\n11    CAPITAL       esriFieldTypeString                Capital sqlTypeOther\n\n\n\n\nFor the sake of readability, only the first 4 columns are displayed.\nLet’s try reading in only the \"STATE_ABBR\", \"POPULATION\", and \"NAME\" fields.\n\narc_select(\n  flayer, \n  fields = c(\"STATE_ABBR\", \"POPULATION\", \"NAME\")\n)\n\nIterating ■■■■■■■■■■■                       33% | ETA:  7s\n\n\nIterating ■■■■■■■■■■■■■■■■■■■■■             67% | ETA:  3s\n\n\nIterating ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:  0s\n\n\nSimple feature collection with 4186 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -159.3191 ymin: 19.58272 xmax: -68.77234 ymax: 64.86928\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   STATE_ABBR POPULATION           NAME                   geometry\n1          AL      33284      Alabaster  POINT (-86.81782 33.2445)\n2          AL      22386    Albertville POINT (-86.21205 34.26421)\n3          AL      14843 Alexander City POINT (-85.95631 32.94309)\n4          AL      21564       Anniston  POINT (-85.81986 33.6565)\n5          AL      25406         Athens  POINT (-86.9508 34.78484)\n6          AL       8391         Atmore POINT (-87.49009 31.02226)\n7          AL      76143         Auburn POINT (-85.48999 32.60691)\n8          AL      26019       Bessemer  POINT (-86.9563 33.40092)\n9          AL     200733     Birmingham  POINT (-86.79647 33.5288)\n10         AL      16494         Calera  POINT (-86.74549 33.1244)\n\n\n\n\nUsing SQL where clauses\nNot only can you limit the number of columns returned from a Feature Layer, but you can also limit the number of rows returned. This is very handy in the case of Feature Layers with hundreds of thousands of features. Reading all of those features into memory would be slow, costly (in terms of memory), and, in many cases, unnecessary!\nThe where argument of arc_select() permits you to provide a very simple SQL where clause to limit the features returned. Let’s explore the use of the where argument.\nLet’s modify the above arc_select() statement to return only the features in California, using the where clause STATE_ABBR = 'CA'\n\narc_select(\n  flayer,\n  where = \"STATE_ABBR = 'CA'\",\n  fields = c(\"STATE_ABBR\", \"POPULATION\", \"NAME\")\n)\n\nSimple feature collection with 498 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -124.1662 ymin: 32.57388 xmax: -114.5903 ymax: 40.93734\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   STATE_ABBR POPULATION         NAME                   geometry\n1          CA      38046     Adelanto  POINT (-117.4384 34.5792)\n2          CA      20299 Agoura Hills POINT (-118.7601 34.15363)\n3          CA      78280      Alameda  POINT (-122.2614 37.7672)\n4          CA      15314        Alamo POINT (-122.0307 37.84998)\n5          CA      20271       Albany POINT (-122.3002 37.88985)\n6          CA      82868     Alhambra POINT (-118.1355 34.08398)\n7          CA      52176  Aliso Viejo POINT (-117.7289 33.57922)\n8          CA      14696       Alpine POINT (-116.7585 32.84388)\n9          CA      42846     Altadena POINT (-118.1356 34.19342)\n10         CA      12042    Alum Rock  POINT (-121.8239 37.3694)\n\n\nYou can also consider finding only the places in the US with more than 1,000,000 people.\n\narc_select(\n  flayer,\n  where = \"POPULATION &gt; 1000000\",\n  fields = c(\"STATE_ABBR\", \"POPULATION\", \"NAME\")\n)\n\nSimple feature collection with 10 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -121.8864 ymin: 29.42354 xmax: -74.01013 ymax: 41.75649\nGeodetic CRS:  WGS 84\n   STATE_ABBR POPULATION         NAME                   geometry\n1          AZ    1608139      Phoenix POINT (-112.0739 33.44611)\n2          CA    3898747  Los Angeles POINT (-118.2706 34.05279)\n3          CA    1386932    San Diego POINT (-117.1456 32.72033)\n4          CA    1013240     San Jose POINT (-121.8864 37.33941)\n5          IL    2746388      Chicago POINT (-87.64715 41.75649)\n6          NY    8804190     New York POINT (-74.01013 40.71057)\n7          PA    1603797 Philadelphia POINT (-75.16099 39.95136)\n8          TX    1304379       Dallas POINT (-96.79576 32.77865)\n9          TX    2304580      Houston POINT (-95.36751 29.75876)\n10         TX    1434625  San Antonio  POINT (-98.4925 29.42354)\n\n\nNow try combining both where clauses using and to find only the cities in California with a population greater than 1,000,000.\n\narc_select(\n  flayer,\n  where = \"POPULATION &gt; 1000000 and STATE_ABBR = 'CA'\",\n  fields = c(\"STATE_ABBR\", \"POPULATION\", \"NAME\")\n)\n\nSimple feature collection with 3 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -121.8864 ymin: 32.72033 xmax: -117.1456 ymax: 37.33941\nGeodetic CRS:  WGS 84\n  STATE_ABBR POPULATION        NAME                   geometry\n1         CA    3898747 Los Angeles POINT (-118.2706 34.05279)\n2         CA    1386932   San Diego POINT (-117.1456 32.72033)\n3         CA    1013240    San Jose POINT (-121.8864 37.33941)",
    "crumbs": [
      "Layers",
      "Reading Feature Services"
    ]
  },
  {
    "objectID": "docs/layers/read-layers.html#using-dplyr",
    "href": "docs/layers/read-layers.html#using-dplyr",
    "title": "Reading Feature Services",
    "section": "Using dplyr",
    "text": "Using dplyr\nIf writing the field names out by hand and coming up with SQL where clauses isn’t your thing, that’s okay. We also provide dplyr::select() and dplyr::filter() methods for FeatureLayer objects.\nThe dplyr functionality is modeled off of dbplyr. The general concept is that you have a connection object that specifies what you will be querying against. Then you build up queries using dplyr functions. Unlike using dplyr on data.frames, the results aren’t fetched eagerly. Instead they are lazy. With dbplyr, you use the collect() function to execute a query and bring it into memory. The same is true with FeatureLayer objects.\nLet’s build up a query and see it in action! First, load dplyr to bring the functions into scope.\n\nlibrary(dplyr)\n\nfl_query &lt;- flayer |&gt; \n  select(STATE_ABBR, POPULATION, NAME)\n\nfl_query\n\n&lt;FeatureLayer&gt;\nName: USA Major Cities\nGeometry Type: esriGeometryPoint\nCRS: 4326\nCapabilities: Query,Extract\nQuery:\n  outFields: STATE_ABBR,POPULATION,NAME\n\n\nAfter doing this, your FeatureLayer object now prints out a Query field with the outFields parameter set to the result of your select() function.\n\n\n\n\n\n\nA note for advanced useRs\n\n\n\n\n\nYou build up and store the query in the query attribute of a FeatureLayer object. It is a named list that will be passed directly to the API endpoint. The names match endpoint parameters.\n\nattr(fl_query, \"query\")\n\n$outFields\n[1] \"STATE_ABBR,POPULATION,NAME\"\n\n\nYou can also manually specify parameters using the update_params() function. Note that there is no parameter validation.\n\nupdate_params(fl_query, key = \"value\")\n\n&lt;FeatureLayer&gt;\nName: USA Major Cities\nGeometry Type: esriGeometryPoint\nCRS: 4326\nCapabilities: Query,Extract\nQuery:\n  outFields: STATE_ABBR,POPULATION,NAME\n  key: value\n\n\n\n\n\nYou can continue to build up your query using filter()\n\n\n\n\n\n\nTip\n\n\n\nOnly very basic filter statements are supported such as ==, &lt;, &gt;, etc.\n\n\n\nfl_query |&gt; \n  filter(POPULATION &gt; 1000000, STATE_ABBR == \"CA\")\n\n&lt;FeatureLayer&gt;\nName: USA Major Cities\nGeometry Type: esriGeometryPoint\nCRS: 4326\nCapabilities: Query,Extract\nQuery:\n  outFields: STATE_ABBR,POPULATION,NAME\n  where: POPULATION &gt; 1000000.0 AND STATE_ABBR = 'CA'\n\n\nThe query is stored in the FeatureLayer object and will not be executed until you request it with collect().\n\nfl_query |&gt; \n  filter(POPULATION &gt; 1000000, STATE_ABBR == \"CA\") |&gt; \n  collect()\n\nSimple feature collection with 3 features and 0 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -121.8864 ymin: 32.72033 xmax: -117.1456 ymax: 37.33941\nGeodetic CRS:  WGS 84\n                    geometry\n1 POINT (-118.2706 34.05279)\n2 POINT (-117.1456 32.72033)\n3 POINT (-121.8864 37.33941)",
    "crumbs": [
      "Layers",
      "Reading Feature Services"
    ]
  },
  {
    "objectID": "docs/layers/read-layers.html#map-and-feature-servers",
    "href": "docs/layers/read-layers.html#map-and-feature-servers",
    "title": "Reading Feature Services",
    "section": "Map and Feature Servers",
    "text": "Map and Feature Servers\nThis example has only illustrated how to work with FeatureLayer objects. However, often times you may wish to work with a collection of layers in a FeatureServer, MapServer, or GroupLayer. All of these are collections of multiple layers. Like a FeatureLayer, these are accessed with arc_open().\n\nfurl &lt;- \"https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/PLACES_LocalData_for_BetterHealth/FeatureServer\"\n\nfsrv &lt;- arc_open(furl)\nfsrv\n\n&lt;FeatureServer &lt;5 layers, 0 tables&gt;&gt;\nCRS: 3785\nCapabilities: Query,Extract\n  0: PlacePoints (esriGeometryPoint)\n  1: PlaceBoundaries (esriGeometryPolygon)\n  2: Counties (esriGeometryPolygon)\n  3: Tracts (esriGeometryPolygon)\n  4: ZCTAs (esriGeometryPolygon)\n\n\nThis FeatureServer contains 5 layers. The individual layers can be fetched using get_layer() which lets us specify the layer by ID or by name. It is recommended to use the ID as that will be less prone to human error (for example a space is secretly a tab). The result of the function is a FeatureLayer object that can be used with arc_select() as illustrated above.\n\nget_layer(fsrv, id = 2)\n\n&lt;FeatureLayer&gt;\nName: Counties\nGeometry Type: esriGeometryPolygon\nCRS: 3785\nCapabilities: Query,Extract\n\n\nSome FeatureServers will also contain tables.\n\nfurl &lt;- \"https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Wetlands/FeatureServer\"\nfsrv2 &lt;- arc_open(furl)\nfsrv2\n\n&lt;FeatureServer &lt;1 layer, 1 table&gt;&gt;\nCRS: 3857\nCapabilities: Query,Extract\n  0: USA_Wetlands (esriGeometryPolygon)\n  1: Pop_Up_Table (Table)\n\n\nThis can be fetched using get_layer() as well.\n\nget_layer(fsrv2, 1)\n\n&lt;Table&gt;\nName: Pop_Up_Table\nCapabilities: Query,Extract\n\n\nIf you would like to fetch multiple items at one time there is a plural get_layers() which will fetch multiple items based on name or id and return a list.\n\nget_layers(fsrv, id = c(0, 2, 4))\n\n[[1]]\n&lt;FeatureLayer&gt;\nName: PlacePoints\nGeometry Type: esriGeometryPoint\nCRS: 3785\nCapabilities: Query,Extract\n\n[[2]]\n&lt;FeatureLayer&gt;\nName: Counties\nGeometry Type: esriGeometryPolygon\nCRS: 3785\nCapabilities: Query,Extract\n\n[[3]]\n&lt;FeatureLayer&gt;\nName: ZCTAs\nGeometry Type: esriGeometryPolygon\nCRS: 3785\nCapabilities: Query,Extract\n\n\nThere is also a helper get_all_layers() to fetch all of layers of a FeatureServer, MapServer, or GroupLayer into a list. The list has two elements layers and tables. The former containing all of the FeatureLayers and the latter containing all of the Tables in the FeatureServer.\n\nget_all_layers(fsrv2)\n\n$layers\n$layers$`0`\n&lt;FeatureLayer&gt;\nName: USA_Wetlands\nGeometry Type: esriGeometryPolygon\nCRS: 3857\nCapabilities: Query,Extract\n\n\n$tables\n$tables$`1`\n&lt;Table&gt;\nName: Pop_Up_Table\nCapabilities: Query,Extract",
    "crumbs": [
      "Layers",
      "Reading Feature Services"
    ]
  },
  {
    "objectID": "docs/layers/publishing.html",
    "href": "docs/layers/publishing.html",
    "title": "Publishing from R",
    "section": "",
    "text": "In addition to consuming data as an R user, you may also want to publish data as a hosted feature service. In this tutorial, you will learn how to publish an sf object  to ArcGIS Online or Enterprise.",
    "crumbs": [
      "Layers",
      "Publishing layers"
    ]
  },
  {
    "objectID": "docs/layers/publishing.html#authorization",
    "href": "docs/layers/publishing.html#authorization",
    "title": "Publishing from R",
    "section": "Authorization",
    "text": "Authorization\nIn order to publish content to ArcGIS Online or Enterprise, you must first obtain an access token permitting you to do so.\n\n\n\n\n\n\nCaution\n\n\n\nIf you have not yet set up your R environment for authorization, see Authorize with your Portal. Ensure that the environment variables ARCGIS_CLIENT and ARCGIS_USER are set at minimum. If you are using ArcGIS Enterprise, ensure that ARCGIS_HOST is properly set as well.\n\n\nGo through the following code flow to set your credentials.\n\nlibrary(arcgis)\n\n1token &lt;- auth_code()\n2set_arc_token(token)\n\n\n1\n\nCreate an access token\n\n2\n\nSet it to an environment variable.\n\n\n\n\nNow that you have authorized to your Portal, you will be able to publish content.",
    "crumbs": [
      "Layers",
      "Publishing layers"
    ]
  },
  {
    "objectID": "docs/layers/publishing.html#publishing-sf-objects",
    "href": "docs/layers/publishing.html#publishing-sf-objects",
    "title": "Publishing from R",
    "section": "Publishing {sf} objects",
    "text": "Publishing {sf} objects\nTo publish an {sf} object to your portal, you can use the function publish_layer(). The publishing process requires you to add an item to your portal and publish it. The publish_layer() function handles these steps for you.\nFirst, read in the North Carolina SIDS dataset that comes packaged with sf and store it in an object called nc.\n\nnc &lt;- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nNow that you have an sf object and you have authorized with your portal, all that’s left is to publish the item!\npublish_layer() has only two required arguments:\n\nx the sf object or data.frame\ntitle the title of layer you are creating\n\n\nres &lt;- publish_layer(nc, \"North Carolina SIDS\")\nres\n#&gt; $services\n#&gt;              type\n#&gt; 1 Feature Service\n#&gt;                                                                                             serviceurl\n#&gt; 1 https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North Carolina SIDS/FeatureServer\n#&gt;     size                                jobId                    serviceItemId\n#&gt; 1 125766 f14451a7-325b-40b0-85c3-534bcf122806 32511ce0413f40d08303e267a7093be0\n#&gt;                                                                                          encodedServiceURL\n#&gt; 1 https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer\n\n\n\n\n\n\n\nWarning\n\n\n\nIf you encounter errors while publishing, try using a feature layer title that does not contain spaces or special characters, such as “NorthCarolinaSIDS” for this example.\n\n\nNow from your Portal’s Content page you should see two items associated with your feature service:\n\nBehind the scenes, publish_layer() added the sf object as a Feature Layer item first and then published this item as a Feature Layer (hosted). After publishing, you will typically only interact with the hosted feature layer. (Note that the dependency between these two items prevents you from deleting the underlying feature layer while the hosted feature layer still exists.)\nClick View details on the hosted feature layer item and you should see something like the below:",
    "crumbs": [
      "Layers",
      "Publishing layers"
    ]
  },
  {
    "objectID": "docs/layers/publishing.html#reading-the-published-feature-layer",
    "href": "docs/layers/publishing.html#reading-the-published-feature-layer",
    "title": "Publishing from R",
    "section": "Reading the published Feature Layer",
    "text": "Reading the published Feature Layer\nThe output of the publish_layer() function is a list that contains information about where the sf object was published. You can retrieve the encodedServiceUrl from the response and use arc_open() to return the metadata for your newly-created service.\n\nnc_fserver &lt;- arc_open(res[[c(\"services\", \"encodedServiceURL\")]])\nnc_fserver\n#&gt; &lt;FeatureServer &lt;1 layer, 0 tables&gt;&gt;\n#&gt; CRS: 4267\n#&gt; Capabilities: Create,Delete,Query,Update,Editing\n#&gt;   0: North Carolina SIDS (esriGeometryPolygon)\n\nYou’ll notice that this is a FeatureServer. All items that are published to a Portal become their own Feature Server with a single FeatureLayer.\nYou can extract a single layer from the FeatureServer using get_layer(). Provide the FeatureServer as the first argument and then the ID of the layer you want as the second argument.\n\nget_layer(nc_fserver, 0)\n#&gt; &lt;FeatureLayer&gt;\n#&gt; Name: North Carolina SIDS\n#&gt; Geometry Type: esriGeometryPolygon\n#&gt; CRS: 4267\n#&gt; Capabilities: Create,Delete,Query,Update,Editing",
    "crumbs": [
      "Layers",
      "Publishing layers"
    ]
  },
  {
    "objectID": "docs/layers/publishing.html#publishing-data.frames",
    "href": "docs/layers/publishing.html#publishing-data.frames",
    "title": "Publishing from R",
    "section": "Publishing data.frames",
    "text": "Publishing data.frames\nPublishing a data.frame follows the same steps as those above. The difference is that it creates a Table object. Try repeating the same process but using the palmerpenguins dataset!\n\n# install.packages(\"palmerpenguins\")\npalmerpenguins::penguins\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npublish_layer(palmerpenguins::penguins, \"Palmer Penguins\")",
    "crumbs": [
      "Layers",
      "Publishing layers"
    ]
  },
  {
    "objectID": "docs/auth/storing-credentials.html",
    "href": "docs/auth/storing-credentials.html",
    "title": "Storing credentials",
    "section": "",
    "text": "Authentication requires that you provide sensitive data to the R authentication R functions. These are used to verify your identity to the services that you are calling. These sensitive variables should never be written down in your code.\nThe packages in the R-ArcGIS Bridge rely heavily on environment variables. Environment variables are dynamic values that can be set to store sensitive or configuration information, allowing you to manage and control access to crucial data across various tools and applications, including R scripts.",
    "crumbs": [
      "Authentication",
      "Storing credentials"
    ]
  },
  {
    "objectID": "docs/auth/storing-credentials.html#environment-variables",
    "href": "docs/auth/storing-credentials.html#environment-variables",
    "title": "Storing credentials",
    "section": "Environment variables",
    "text": "Environment variables\nThe package {arcgisutils} is responsible for handling authorization for all of the R packages. With it, there are a number of different mechanism for authorizing each requiring a different combination of environment variables.\nEnvironment variables are fetched using Sys.getenv(). They are key-value pairs. For example, to find the path of R run\n\nSys.getenv(\"R_HOME\")\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources\"\n\n\nOr to set a value use Sys.setenv()\n\nSys.setenv(\"ANSWER_TO_EVERYTHING\" = 42)\nSys.getenv(\"ANSWER_TO_EVERYTHING\")\n\n[1] \"42\"",
    "crumbs": [
      "Authentication",
      "Storing credentials"
    ]
  },
  {
    "objectID": "docs/auth/storing-credentials.html#using-an-.renviron-file",
    "href": "docs/auth/storing-credentials.html#using-an-.renviron-file",
    "title": "Storing credentials",
    "section": "Using an .Renviron file",
    "text": "Using an .Renviron file\nEnvironment variables should never be included in your code. We recommend using an .Renviron file at minimum to store your credentials.\nYou can use the usethis to edit the file. Ensure it is installed and run the following in your text editor:\n\n\n\n\n\n\nWarning\n\n\n\nIf you modify environment variables you will need to restart your R session for the change to be registered.\n\n\nusethis::edit_r_environ()\n\n\n\n\n\n\n.Renviron scopes\n\n\n\n\n\n.Renviron files can be created at a user level or a project level. It is recommended to use project level .Renviron files when deploying scripts to production. If most of your work is interactive then a user level file is sufficient.\nProject scoped .Renviron files store environment variables that are available for the project only. The .Renviron is stored at the root folder level.\nUser scoped .Renviron files store environment variables in the user’s home directory. The environment variables will be available to you in any project you open. However, if you share your project, the environment variables will not be shared with it.\n\n\n\nThis will open your .Renviron file for you to edit.\n# used for OAuth Code & Client\nARCGIS_CLIENT=your-client-id\n# used for OAuth Client flow\nARCGIS_SECRET=your-super-secret-key\n# used for publishing and Username/Password auth\nARCGIS_USER=your-user-name\n# used for API Key auth\nARCGIS_API_KEY=your-developer-api-key\n# specify if not using ArcGIS Online\nARCGIS_HOST=https://your-portal.com/",
    "crumbs": [
      "Authentication",
      "Storing credentials"
    ]
  },
  {
    "objectID": "docs/installation.html",
    "href": "docs/installation.html",
    "title": "Install and set up",
    "section": "",
    "text": "Before installing, we recommend that you have the newest version of R installed. At minimum, we sugest you use R version 4.3 or higher.",
    "crumbs": [
      "Install and set up"
    ]
  },
  {
    "objectID": "docs/installation.html#from-pro",
    "href": "docs/installation.html#from-pro",
    "title": "Install and set up",
    "section": "Install within ArcGIS Pro (recommended)",
    "text": "Install within ArcGIS Pro (recommended)\nIf you are working in ArcGIS Pro 2.0 or beyond, you have access to the built-in installer, which streamlines the process of installing arcgisbinding. It also allows you to select your desired installation of R, and makes checking the bridge for updates easy. To install the bridge in this scenario:\n\nOpen ArcGIS Pro and click on the Project tab in your project.\nSelect Options on the blue, left-hand side panel and in the pop-up window, under Application, select Geoprocessing.\nUnder the R-ArcGIS Support options, select your desired R home directory.\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\n\nNote: All versions of R installed on your computer will appear in the drop-down menu. Make sure the version you select is R 3.2.2 or later. However, if you have installed R to a location other than the default, you might need to navigate to that location using the browse button.\n\n\n\n\nIf you have never installed arcgisbinding, you will see a warning indicating that you need to install the package to enable R to connect with ArcGIS Pro. When you click on the icon next to the warning you will be presented with options to install arcgisbinding from the internet, download the latest version of the package, or install the package from file. Select the first option - Install package from the Internet - to install the arcgisbinding package.\n\n\n\n\n\n\n\nA pop-up window will appear to inform you there is a new arcgisbinding version and will ask you if you wish to install it. Select Yes.\nA progress bar will appear to inform you of the status of the installation before showing an Output Message to report the final status. If you scroll down, you should see that the package arcgisbinding was successfully installed. The package will now show as installed in the R-ArcGIS Support section of the Options window.",
    "crumbs": [
      "Install and set up"
    ]
  },
  {
    "objectID": "docs/installation.html#from-r",
    "href": "docs/installation.html#from-r",
    "title": "Install and set up",
    "section": "Install from R",
    "text": "Install from R\nAlternatively, you can install arcgisbinding directly from R. Open RStudio, VS Code, or your favorite text editor and run the following from the console:\n install.packages(\n  \"arcgisbinding\", \n  repos = \"https://r.esri.com\", \n  type = \"win.binary\"\n )\nThis will install the package binary directly from the R-ArcGIS GitHub repository, which stores the builds of the package. Note that installing this way still has the same requirements. The package is a Windows binary and must be installed on a Windows computer.",
    "crumbs": [
      "Install and set up"
    ]
  },
  {
    "objectID": "docs/installation.html#offline",
    "href": "docs/installation.html#offline",
    "title": "Install and set up",
    "section": "Offline Installation",
    "text": "Offline Installation\nMany users of arcgisbinding work in a completely air-gapped environment where downloading external packages from the internet is not possible.\nIn order to install arcgisbinding in an air-gapped environment you must first download the package on a machine with internet access and transfer it into your offline environment.\nTo download the package, go to https://r.esri.com/bin/ and choose the version of arcgisbinding that matches your version of R.\nOnce you have downloaded and moved the zip file onto your air-gapped machine, you can install it using the install.packages() command.\ninstall.packages(\"path/to/arcgisbinding_1.0.1.306.zip\", repos = NULL)\n\n\n\n\n\n\nWarning\n\n\n\nNote that depending on the version of the package you download, the file name will be different. Be sure the file path and name are accurate.",
    "crumbs": [
      "Install and set up"
    ]
  },
  {
    "objectID": "docs/installation.html#verify-your-installation",
    "href": "docs/installation.html#verify-your-installation",
    "title": "Install and set up",
    "section": "Verify your installation",
    "text": "Verify your installation\nOnce you have arcgisbinding installed, you can check if your installation was successful by loading the package.\nlibrary(arcgisbinding)\narc.check_product()\nThis will print a message informing you of the version of ArcGIS Pro you are using. You do not need to install arcgisbinding again until you download a new version of R or wish to upgrade the package.",
    "crumbs": [
      "Install and set up"
    ]
  },
  {
    "objectID": "docs/installation.html#upgrading-arcgisbinding",
    "href": "docs/installation.html#upgrading-arcgisbinding",
    "title": "Install and set up",
    "section": "Upgrading {arcgisbinding}",
    "text": "Upgrading {arcgisbinding}\n\nUsing ArcGIS Pro\nIf you have installed arcgisbinding from within ArcGIS Pro, follow the instructions for accessing ArcGIS Pro’s R-ArcGIS Support options in the installing within ArcGIS Pro section.\nIf you have previously installed arcgisbinding, you will see an installed message that lets you know the version of your arcgisbinding package and allows you to check for updates, download the latest version, or update from a file. Check for updates and ensure you have the latest version of the arcgisbinding package. If prompted to update, click Yes and the latest version will automatically be installed.\n\n\nUsing R or offline\nTo upgrade your package using R or in an offline environment, repeat the steps above for either installing from R or offline installation.",
    "crumbs": [
      "Install and set up"
    ]
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "{arcgisbinding} - documentation | vignette\n{arcgis} - documentation\n{arcgislayers} - documentation\n{arcgisutils} - documentation\n{arcpbf} - documentation\n\n\n\n\n\nUsing the R-ArcGIS Bridge with {arcgisbinding}\nArcGIS Learn Lesson: Get Started with R and ArcGIS\nArcGIS Technology for Spatial Data Science"
  },
  {
    "objectID": "resources.html#learn-about-r-arcgis-bridge",
    "href": "resources.html#learn-about-r-arcgis-bridge",
    "title": "Resources",
    "section": "",
    "text": "{arcgisbinding} - documentation | vignette\n{arcgis} - documentation\n{arcgislayers} - documentation\n{arcgisutils} - documentation\n{arcpbf} - documentation\n\n\n\n\n\nUsing the R-ArcGIS Bridge with {arcgisbinding}\nArcGIS Learn Lesson: Get Started with R and ArcGIS\nArcGIS Technology for Spatial Data Science"
  },
  {
    "objectID": "resources.html#learn-about-arcgis",
    "href": "resources.html#learn-about-arcgis",
    "title": "Resources",
    "section": "Learn about ArcGIS",
    "text": "Learn about ArcGIS\n\nArcGIS location services documentation\nArcGIS REST API documentation\nArcGIS Pro resources\nArcGIS Online resources\nArcGIS Enterprise resources\nArcGIS Tutorial Gallery\nEsri Training"
  },
  {
    "objectID": "resources.html#learn-about-r",
    "href": "resources.html#learn-about-r",
    "title": "Resources",
    "section": "Learn about R",
    "text": "Learn about R\n\nR\nR for Data Science\nGeocomputation with R\nSpatial Data Science: With Applications in R\nCRAN"
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "Packages",
    "section": "",
    "text": "For ArcGIS Pro users\n\nThe original R-ArcGIS Bridge package. arcgisbinding interacts with ArcGIS Pro to provide native reading and writing capabilities to local data sources as well as enables R based geoprocessing script tools."
  },
  {
    "objectID": "packages.html#arcgisbinding",
    "href": "packages.html#arcgisbinding",
    "title": "Packages",
    "section": "",
    "text": "For ArcGIS Pro users\n\nThe original R-ArcGIS Bridge package. arcgisbinding interacts with ArcGIS Pro to provide native reading and writing capabilities to local data sources as well as enables R based geoprocessing script tools."
  },
  {
    "objectID": "packages.html#arcgis",
    "href": "packages.html#arcgis",
    "title": "Packages",
    "section": "{arcgis}",
    "text": "{arcgis}\nFor analysts & data scientists\n\narcgis is a metapackage that loads all location services packages for you."
  },
  {
    "objectID": "packages.html#arcgislayers",
    "href": "packages.html#arcgislayers",
    "title": "Packages",
    "section": "{arcgislayers}",
    "text": "{arcgislayers}\nFor analysts & data scientists\n\nInterfaces with Feature Services and Image Servers. Enables you to read and write to services directly from R."
  },
  {
    "objectID": "packages.html#arcgisutils",
    "href": "packages.html#arcgisutils",
    "title": "Packages",
    "section": "{arcgisutils}",
    "text": "{arcgisutils}\nFor Package Developers\n\nA low-level package to handle authorization and conversion to and from Esri json formats."
  },
  {
    "objectID": "packages.html#arcpbf",
    "href": "packages.html#arcpbf",
    "title": "Packages",
    "section": "{arcpbf}",
    "text": "{arcpbf}\nFor Package Developers \n\nRead ArcGIS Protocol Buffer format (PBF) from R. Utilized in processing responses from REST API requests."
  },
  {
    "objectID": "geoprocessing-tools.html",
    "href": "geoprocessing-tools.html",
    "title": "Geoprocessing Tools",
    "section": "",
    "text": "Much like a Python geoprocessing (GP) script tool, you can also create R-based GP script tools and toolboxes utilizing the power of R.\nThe basic anatomy of an R-based GP script tool is like so:\n\n\nmy-geoprocessing-tool.R\n\n1tool_exec &lt;- function(in_params, out_params) {\n  # ... do things here.. \n2  out_params\n}\n\n\n1\n\nTwo arguments capture input and output parameters\n\n2\n\nOutput parameters are returned to be captured by ArcGIS Pro\n\n\nR-based GP script tools are defined in a standalone R script. The GP tool is defined by a function called tool_exec(). tool_exec() takes exactly two arguments capturing input and output parameters. tool_exec() should always return the output parameter argument."
  },
  {
    "objectID": "geoprocessing-tools.html#overview",
    "href": "geoprocessing-tools.html#overview",
    "title": "Geoprocessing Tools",
    "section": "",
    "text": "Much like a Python geoprocessing (GP) script tool, you can also create R-based GP script tools and toolboxes utilizing the power of R.\nThe basic anatomy of an R-based GP script tool is like so:\n\n\nmy-geoprocessing-tool.R\n\n1tool_exec &lt;- function(in_params, out_params) {\n  # ... do things here.. \n2  out_params\n}\n\n\n1\n\nTwo arguments capture input and output parameters\n\n2\n\nOutput parameters are returned to be captured by ArcGIS Pro\n\n\nR-based GP script tools are defined in a standalone R script. The GP tool is defined by a function called tool_exec(). tool_exec() takes exactly two arguments capturing input and output parameters. tool_exec() should always return the output parameter argument."
  },
  {
    "objectID": "geoprocessing-tools.html#input-and-output-parameters",
    "href": "geoprocessing-tools.html#input-and-output-parameters",
    "title": "Geoprocessing Tools",
    "section": "Input and Output Parameters",
    "text": "Input and Output Parameters\nThere must be two arguments that correspond to input parameters and output parameters. The conventional names of these arguments are in_params and out_params. The first argument will always refer to the input parameters and the second to the outputs.\nin_params and out_params are named lists. The elements of these lists are determined by the direction of a parameter.\n\nIf the direction is Input, it will be contained in in_params. Likewise, if the direction is Output, it will be contained in out_params."
  },
  {
    "objectID": "geoprocessing-tools.html#using-parameters",
    "href": "geoprocessing-tools.html#using-parameters",
    "title": "Geoprocessing Tools",
    "section": "Using parameters",
    "text": "Using parameters\nValues can be extracted from the in_params and out_params lists by the name or position of the parameter. It is strongly recommended to use name-based indexing rather than position-based indexing for clarity.\n\n\n\n\n\n\nCaution\n\n\n\nThe name of the parameter must match the value in the Name (not Label) column in the Parameters tab of the Tool Properties.\n\n\nThis is an example of a function to parse a date parameter with the name date:\ntool_exec &lt;- function(in_params, out_params) {\n  # fetch the date parameter\n  date_str &lt;- in_params[[\"date\"]]\n  \n  # parse it using {anytime}\n  clean_date &lt;- anytime::anytime(date_str)\n  \n  # ... do additional things\n  \n  # return values to ArcGIS Pro\n  out_params\n}\n\nReturning values to ArcGIS Pro\nAt the end of the tool_exec() function above, the out_params object is returned. Returning the output parameters using this syntax allows ArcGIS Pro to capture and use the outputs of the script tool.\nNotably, the output parameters are useful in linking one tool to another, for example via use in ModelBuilder or in an arcpy script.\nSee Using R script tools with arcpy.\n\n\nParameter types\nThere are number of different parameter types that can be provided to a geoprocessing (GP) tool. The type of parameter that is chosen determines how that parameter will appear in the Geoprocessing pane. Each ArcGIS Pro parameter type can be represented by a basic scalar R type: integer, double, character, logical, or NULL.\n\n\n\n\n\n\nTip\n\n\n\nA scalar value is a vector with only a single element.\n\n\nIt is incumbent upon the developer to take these parameter inputs and use them appropriately in R. Not every type of parameter can be processed correctly by arcgisbinding. Below are examples of common parameter types and how they are handled by arcgisbinding:\n\nData type mapping\n\n\n\n\n\n\nArcGIS Pro Parameter Type\nR Data Type\n\n\n\n\nString\ncharacter\n\n\nBoolean\nlogical\n\n\nDouble\nnumeric\n\n\nDate\ncharacter in the format of your system e.g. \"11/17/2023 4:35:57 PM\"\n\n\nField\ncharacter the field name of a feature class\n\n\nFolder\ncharacter absolute path e.g. \"C:\\\\Users\\username\\Documents\"\n\n\nFeature Class\ncharacterabsolute path e.g. \"C:\\\\Users\\username\\mydatabase.gdb\\\\feature_class\n\n\nSpatial Reference\ncharacter a string representation of the spatial reference e.g. \"PROJCS[\"....\"]\"\n\n\n\nFor a complete list of parameter data types, see Geoprocessing data types.\n\n\nMultiple Values\nWhen selecting the Multiple values check box in the parameter data type dialog box, users can then provide multiple inputs of that type.\n\nWhen the Multiple values option is enabled, the parameter returns a list containing each of the input values.\nNote that when multiple values are provided, they will be captured in R as a list of scalars. Take the below input, for example:\n\nIn R, this parameter value would be list(\"string 1\", \"string 2\") and not c(\"string 1\", \"string 2\").\n\n\n\n\n\n\nTip\n\n\n\nTo turn a list of scalars of the same type—e.g. double, integer, logical, or character—into a vector, use unlist(). For example unlist(list(\"string 1\", \"string 2\")) returns c(\"string 1\", \"string 2\")."
  },
  {
    "objectID": "geoprocessing-tools.html#common-patterns",
    "href": "geoprocessing-tools.html#common-patterns",
    "title": "Geoprocessing Tools",
    "section": "Common Patterns",
    "text": "Common Patterns\n\nReading a Feature Class\nReading a feature class using arcgisbinding and bringing the results into R as an sf object is a common pattern. To do this, use the functions arc.open(), arc.select(), and arc.data2sf().\ntool_exec &lt;- function(in_params, out_params) {\n\n  fclass &lt;- arcgisbinding::arc.open(in_params[[\"fc_path\"]])\n  \n  fclass_selected &lt;- arcgisbinding::arc.select(\n    fclass,\n    # fields = c(\"optional\", \"fields\", \"to\", \"read\"),\n    # where_clause = \"optional sql where clause to filter\"\n  )\n  \n  fclass_sf &lt;- arcgisbinding::arc.data2sf(fclass_selected)\n}\n\n\n\n\n\n\nNote\n\n\n\nTo filter or select columns from a dataset, consider using the fields and where_clause arguments of arc.select() to reduce the amount of data read into memory.\narc.select() returns a data.frame with fields and a special geometry column which is incompatible with sf. Use arc.data2sf() to convert it to an sf object.\n\n\n\n\nWriting a Feature Class\nIt is quite common to write the results of an analysis to a file geodatabase. This can be done with arc.write(). A Feature Class type parameter can be used in the out_params list object to capture a user-defined output path.\narc.write() requires two arguments. The first is the output path to write to and the second is the object to write. The accepted types of objects are data.frame, sf, RasterLayer or RasterBrick.\n\n\n\n\n\n\nNote\n\n\n\nSupport for {terra} is planned to accompany the ArcGIS Pro 3.3 release.\n\n\ntool_exec &lt;- function(in_params, out_params) {\n  \n  # extract the path to write to\n  out_fp &lt;- out_params[[\"output_fclass\"]]\n  \n  # write the `sf_object` to a geodatabase\n  arcgisbinding::arc.write(out_fp, sf_object)\n  \n}\n\n\nInstalling Required Packages\nWhen sharing R-based GP tools with other users, they may not have the packages that the script tool needs to execute code. In this case, required packages can be automatically installed the first time the script tool is executed.\nThe script tool can check to see if the required package is installed and, if not, install it. Below is a helper function to include at the top of the script if there are multiple packages to check:\ninstall_if_not &lt;- function(pkg) {\n  if (!requireNamespace(pkg)) {\n    message(\"Installing required package `{\", pkg, \"}`\")\n    install.packages(pkg)\n  }\n}\nThis function uses requireNamespace() which attempts to load the provided package. If it succeeds, it returns TRUE, and if not it returns FALSE. The function checks to see if FALSE is returned and, if so, installs the package and prints an informative message.\nFor example, if the script requires the package {spdep} and it is not installed, the function will print the message and install the package.\ntool_exec &lt;- function(in_params, out_params) {\n  # check for required packages \n  install_if_not(\"spdep\")\n  \n  # do other things with spdep\n  # ...\n}"
  },
  {
    "objectID": "geoprocessing-tools.html#using-progressors",
    "href": "geoprocessing-tools.html#using-progressors",
    "title": "Geoprocessing Tools",
    "section": "Using Progressors",
    "text": "Using Progressors\nGeoprocessing tools have a progressor, which includes both a progress label and a progress bar. The default progressor continuously moves back and forth to indicate the script is running. Using arc.progress_label() and arc.progress_pos() allows fine control over the script progress. Updating the progressor isn’t necessary, but is useful in situations where solely outputting messages to the dialog is insufficient to communicate script progress.\n\n\n\n\n\n\n\n\n\nDefault Progressor\n\n\n\n\n\n\n\nStep Progressor\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRead more in the Understanding the progressor in script tools article.\n\n\nUsing arc.progress_label() allows control over the label that is displayed at the top of the running script. For example, it might be used to display the current step of the analysis taking place. Using arc.progress_pos() allows control over the progressor position displayed at the top of the running script. The position is an integer percentage, 0 to 100, that the progress bar should be set to, with 100 indicating the script has completed (100%).\nlibrary(arcgisbinding)\n\ntool_exec &lt;- function(in_params, out_params) {\n  \n  # read feature class \n  arc.progress_label(\"Reading Feature Class\")\n  fclass &lt;- arc.open(in_params[[\"input_fclass\"]])\n  \n  # convert to sf\n  arc.progress_label(\"Converting Feature Class to sf\")\n  sf_obj &lt;- arc.data2sf(arc.select(fclass))\n  \n  # do other things \n  arc.progress_label(\"Doing other computations\")\n  \n  return(out_params)\n}"
  },
  {
    "objectID": "geoprocessing-tools.html#arcpy-integration",
    "href": "geoprocessing-tools.html#arcpy-integration",
    "title": "Geoprocessing Tools",
    "section": "Using R script tools with arcpy",
    "text": "Using R script tools with arcpy"
  },
  {
    "objectID": "geoprocessing-tools.html#dependent-parameters",
    "href": "geoprocessing-tools.html#dependent-parameters",
    "title": "Geoprocessing Tools",
    "section": "Dependent Parameters",
    "text": "Dependent Parameters\n\nAutopopulate field drop-down using dependent parameter"
  },
  {
    "objectID": "docs/auth/index.html",
    "href": "docs/auth/index.html",
    "title": "Overview",
    "section": "",
    "text": "There a number of times when you will need to verify who you say you are when using ArcGIS location services. This is done through a process called authentication. Authentication is required when you want to"
  },
  {
    "objectID": "docs/auth/index.html#sign-up-for-an-account",
    "href": "docs/auth/index.html#sign-up-for-an-account",
    "title": "Overview",
    "section": "Sign up for an account",
    "text": "Sign up for an account\nTo access certain content, services, or organizations, you will need to be signed in to eithe an ArcGIS Developer account, ArcGIS Online account, or ArcGIS Enterprise account. The type of account, user type, and role you need depends on the resource you need to access and the operations you wish to undertake.\nIf you do not have an account, select one of the options below:\n\nGet started for free with ArcGIS Platform\nGet a free trial of ArcGIS Online\n\n\n\n\n\n\n\nTip\n\n\n\nTo get an account for an existing ArcGIS organization contact your ArcGIS Online or ArcGIS Enterprise administrator."
  },
  {
    "objectID": "docs/auth/index.html#authentication-functions",
    "href": "docs/auth/index.html#authentication-functions",
    "title": "Overview",
    "section": "Authentication functions",
    "text": "Authentication functions\nAt a high-level, the R package {arcgisutils} provides the following functions for authentication:\n\nauth_key(): uses a developer API key\nauth_user(): username and password\nauth_code(): OAuth2 Code flow\nauth_client(): OAuth2 client flow\nauth_binding(): inherits auth from ArcGIS Pro"
  },
  {
    "objectID": "docs/places/overview.html",
    "href": "docs/places/overview.html",
    "title": "Overview",
    "section": "",
    "text": "{arcgisplaces} is an R package to interface with ArcGIS Places Service.\nIn order to use {arcgisplaces} you will need an ArcGIS Developers account. Get started here.",
    "crumbs": [
      "Places",
      "Overview"
    ]
  },
  {
    "objectID": "docs/places/overview.html#installation",
    "href": "docs/places/overview.html#installation",
    "title": "Overview",
    "section": "Installation",
    "text": "Installation\n{arcgisplaces} can be installed directly from CRAN using\ninstall.packages(\"arcgisplaces\")",
    "crumbs": [
      "Places",
      "Overview"
    ]
  },
  {
    "objectID": "docs/places/overview.html#usage",
    "href": "docs/places/overview.html#usage",
    "title": "Overview",
    "section": "Usage",
    "text": "Usage\nThe Places service enables you to find points of interest (POI) based on a location or a bounding box as well as filter your results based on a category or search text.\nFinding places:\n\nnear_point(): search for places near a location.\nwithin_extent(): search for places within an extent.\nplace_details(): get detailed information about the places returned from near_point() or within_extent().\n\nNote: see fields for the possible attributes to return for place details.\n\n\nUnderstanding categories:\n\ncategories(): find categories by name or ID.\ncategory_details(): get detailed information about the categories returned from categories().\nFind place attributes such as name, address, description, opening hours, price ratings, user ratings, and social links.",
    "crumbs": [
      "Places",
      "Overview"
    ]
  },
  {
    "objectID": "docs/places/overview.html#examples",
    "href": "docs/places/overview.html#examples",
    "title": "Overview",
    "section": "Examples",
    "text": "Examples\narcgisutils is needed for authentication. The Places API supports either using an API key via auth_key() or one generated via OAuth2 using either auth_client() or auth_code(). See API documentation for more.\n\nlibrary(arcgisutils)\nlibrary(arcgisplaces)\n\n# Authenticate with a Developer Account API Key\ntoken &lt;- auth_key()\nset_arc_token(token)",
    "crumbs": [
      "Places",
      "Overview"
    ]
  },
  {
    "objectID": "docs/places/overview.html#place-search",
    "href": "docs/places/overview.html#place-search",
    "title": "Overview",
    "section": "Place search",
    "text": "Place search\nYou can search for places near a location with near_point().\n\ncoffee &lt;- near_point(x = -122.334, y = 47.655, search_text = \"Coffee\")\ncoffee\n\nSimple feature collection with 8 features and 5 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -1122.334 ymin: -952.345 xmax: 877.666 ymax: 1047.655\nGeodetic CRS:  WGS 84\n                          place_id                                 name\n1 f6059fc575735b5e3f558c96ab69e6f6 Irwin's Neighborhood Bakery and Cafe\n2 88a10ccf031f02ef2697591f72e1e169                          Fuel Coffee\n3 5cc2d40bf37bff287382057c5fdf4978                            Young Tea\n4 a8c6da1aa0d08fe96e5d80d0f3b3de03                     Friday Afternoon\n5 906da2fe5164619199a2f2ba9c99a650                            Starbucks\n6 957c39de6e0a0eb8afeb841d456c72fc                   Mosaic Coffeehouse\n7 4bdfa82268e67a698d0b8ea3d2df3853                          A Muddy Cup\n8 090286b411e3337850ec8fff6b43569b                           The Bounty\n  distance   categories icon                   geometry\n1     97.0 c(\"13002.... &lt;NA&gt; POINT (-122.3328 47.65539)\n2    723.8 c(\"13035.... &lt;NA&gt; POINT (-122.3369 47.66122)\n3    727.6 c(\"13033.... &lt;NA&gt; POINT (-122.3331 47.66152)\n4    740.8 c(\"13036.... &lt;NA&gt;  POINT (-122.342 47.65895)\n5    767.3 13035, C.... &lt;NA&gt; POINT (-122.3361 47.66175)\n6    774.0 c(\"13034.... &lt;NA&gt; POINT (-122.3276 47.66048)\n7    964.2 c(\"13035.... &lt;NA&gt; POINT (-122.3255 47.66149)\n8    976.2 c(\"13034.... &lt;NA&gt; POINT (-122.3426 47.66162)\n\n\nLocations are returned as an sf object with the place ID, the place name, distance from the search point, a character vector of categories.\n\n\n\n\n\n\nTip\n\n\n\narcgisplaces will return an sf object, but the sf package is not required to work with the package. The sf print method will not be used unless the package is loaded. If package size is a consideration—i.e. deploying an app in a Docker container—consider using wk or rsgeo.\n\n\nDetails for the places can be fetched using place_details(). The possible fields are documented online as well as contained in the exported vector fields. Because pricing is dependent upon which fields are requested, it is a required argument.\nTo get the add requested_fields = \"hours\". Note, that the other possible fields will still be present in the result, but completely empty.\n\ndetails &lt;- place_details(\n  coffee$place_id,\n  requested_fields = \"rating\"\n)\n\ndetails[c(\"price\", \"user\")]\n\nSimple feature collection with 8 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: Inf ymin: Inf xmax: -Inf ymax: -Inf\nGeodetic CRS:  WGS 84\n     price user    location\n1    Cheap  4.1 POINT EMPTY\n2    Cheap  3.9 POINT EMPTY\n3     &lt;NA&gt;   NA POINT EMPTY\n4 Moderate   NA POINT EMPTY\n5    Cheap  3.4 POINT EMPTY\n6    Cheap  3.0 POINT EMPTY\n7    Cheap  4.0 POINT EMPTY\n8     &lt;NA&gt;   NA POINT EMPTY\n\n\nOr, you can search for places within a bounding box using within_extent(). This could be quite handy for searching within current map bounds, for example.\n\nbakeries &lt;- within_extent(\n  -70.356, 43.588, -70.176, 43.7182,\n  category_id = \"13002\"\n)\n\nbakeries[c(\"name\")]\n\nSimple feature collection with 24 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -70.356 ymin: 43.588 xmax: -70.176 ymax: 43.7182\nGeodetic CRS:  WGS 84\nFirst 10 features:\n                      name                   geometry\n1             Panera Bread POINT (-70.32966 43.67791)\n2           Crumbl Cookies POINT (-70.33067 43.67675)\n3       Electric Bike Cafe  POINT (-70.2864 43.63655)\n4     BenReuben’s Knishery POINT (-70.25299 43.63748)\n5      Two Fat Cats Bakery  POINT (-70.26101 43.6327)\n6            Auntie Anne's POINT (-70.33517 43.63372)\n7           Lolli and Pops POINT (-70.33512 43.63377)\n8             Panera Bread   POINT (-70.3303 43.6367)\n9   Cookie Jar Pastry Shop POINT (-70.22644 43.63367)\n10 Bake Maine Pottery Cafe POINT (-70.25334 43.66708)",
    "crumbs": [
      "Places",
      "Overview"
    ]
  },
  {
    "objectID": "docs/layers/overview.html",
    "href": "docs/layers/overview.html",
    "title": "Overview",
    "section": "",
    "text": "Layers represent represent a data service hosted by ArcGIS Online, ArcGIS Enterprise, Platform, or even an ArcGIS Hub site. Layers are how you will interact with your remotely hosted data.\nThe {arcgis} R metapackage is able to work with the most common types of data services: feature services and image servers. The types of layers that the R-ArcGIS Bridge does not yet support are vector and map tile services.",
    "crumbs": [
      "Layers",
      "Overview"
    ]
  },
  {
    "objectID": "docs/layers/overview.html#creating-data-service-objects",
    "href": "docs/layers/overview.html#creating-data-service-objects",
    "title": "Overview",
    "section": "Creating data service objects",
    "text": "Creating data service objects\nUsing {arcgislayers}, the function arc_open() will create a reference to a service based on its url.\n\nlibrary(arcgis)\n\nAttaching core arcgis packages:\n→ arcgisutils v0.3.0\n→ arcgislayers v0.2.0\n\n# feature service url\nfurl &lt;- \"https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/PLACES_LocalData_for_BetterHealth/FeatureServer/4\"\n\n# feature layer\nflayer &lt;- arc_open(furl)\nflayer\n\n&lt;FeatureLayer&gt;\nName: ZCTAs\nGeometry Type: esriGeometryPolygon\nCRS: 3785\nCapabilities: Query,Extract",
    "crumbs": [
      "Layers",
      "Overview"
    ]
  },
  {
    "objectID": "docs/layers/overview.html#querying-feature-services",
    "href": "docs/layers/overview.html#querying-feature-services",
    "title": "Overview",
    "section": "Querying feature services",
    "text": "Querying feature services\nTo bring data from the service into memory in R, you must use arc_select().\n\n\n\n\n\n\nTip\n\n\n\nAlways bring as little data as possible into memory. Utilize the fields and where arguments.\n\n\n\narc_select(\n  flayer,\n  where = \"TotalPopulation &gt; 100000\",\n  fields = c(\"objectid\", \"totalpopulation\", \"zcta5\")\n)\n\nSimple feature collection with 9 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13185850 ymin: 3724192 xmax: -8218971 ymax: 5130142\nProjected CRS: WGS 84 / Pseudo-Mercator\n  OBJECTID TotalPopulation ZCTA5                       geometry\n1     1665          111086 79936 MULTIPOLYGON (((-11831249 3...\n2     2387          103892 90011 MULTIPOLYGON (((-13164358 4...\n3     2669          101279 90201 MULTIPOLYGON (((-13157079 4...\n4     2732          105549 90650 MULTIPOLYGON (((-13141865 4...\n5     3027          103689 91331 MULTIPOLYGON (((-13178819 4...\n6    19391          113916 60629 MULTIPOLYGON (((-9767482 51...\n7    25238          109931 11368 MULTIPOLYGON (((-8219675 49...\n8    25242          100820 11373 MULTIPOLYGON (((-8222572 49...\n9    26364          101572 11226 MULTIPOLYGON (((-8231772 49...",
    "crumbs": [
      "Layers",
      "Overview"
    ]
  },
  {
    "objectID": "docs/editing/overview.html",
    "href": "docs/editing/overview.html",
    "title": "Editing layers",
    "section": "",
    "text": "Published feature layers often are living datasets. There may be new features that need to be added. Or, sometimes features may be need to be deleted as they are no longer present. Or maybe, the attributes of the feature have become obsolete and need to be updated.\nThe {arcgislayers} R package provides capabilities to add features, update them, delete features, or even truncate an entire feature service.",
    "crumbs": [
      "Editing",
      "Overview"
    ]
  },
  {
    "objectID": "docs/editing/overview.html#important-considerations",
    "href": "docs/editing/overview.html#important-considerations",
    "title": "Editing layers",
    "section": "Important considerations",
    "text": "Important considerations\nIt is important to note that not everyone can edit an existing feature service. You must be an admin or an owner of the service that you want to edit. This requires that you have an account and can authorized yourself as a user.\nAdditionally, fields cannot be added or deleted to an already existing feature service. If you wish to add or delete fields, you will need to publish a new layer.",
    "crumbs": [
      "Editing",
      "Overview"
    ]
  },
  {
    "objectID": "docs/editing/update-features.html",
    "href": "docs/editing/update-features.html",
    "title": "Updating features",
    "section": "",
    "text": "In the previous section we added a new feature that is the average of our numeric columns and stored the results in the variable nc_avgs. When looking at it, we can see that the AREA AND PERIMETER values are missing. These might be helpful at a later point.\n\nlibrary(arcgis)\nset_arc_token(auth_code())\n\nnc_url &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\" \n\nnc &lt;- arc_open(nc_url)\n\nIn this section we will use the function update_features() to modify these values. First, let’s create a new object called to_update that has the AREA and PERIMETER computed.\n\nnc_area_perim &lt;- nc_avgs |&gt; \n  mutate(\n    AREA = st_area(geometry) / 1e10,\n    PERIMETER = s2::s2_perimeter(geometry) / 1e5\n  )\n\nnc_area_perim\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id           AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259 [m^2]  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...\nLike add_features(), we need to be able to match columns to their respective fields. The match_on argument is used to specify if the column names match the field name or field alias.\nIn the case of update_features() we also need to be able to match the features in the sf dataset to the exact feature in the FeatureLayer. We do this by providing the object ID of the feature. This tells ArcGIS which features we are actually going to update.\nWhen using update_features() we should be aware that every column present in the sf object will be updated including the geometry. For this reason, we should select only those columns which we truly wish to update.\n\nto_update &lt;- nc_area_perim |&gt; \n  st_drop_geometry() |&gt; \n  select(object_id, AREA, PERIMETER)\n\nto_update\n\nHere we use sf::st_drop_geometry()to remove the geometry of our object since we do not want to update the geometry in our FeatureLayer. We also only select the object_id, AREA, and PERIMETER columns so that we do not make errant updates.\n\nupdate_res &lt;- update_features(nc, to_update)\n\n$updateResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\nOur update process was successful! We can repeat our previous query to verify this.\n\n nc |&gt; \n  filter(NAME == \"Total\") |&gt; \n  collect()\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id     AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...",
    "crumbs": [
      "Editing",
      "Updating features"
    ]
  },
  {
    "objectID": "docs/editing/overwrite-features.html",
    "href": "docs/editing/overwrite-features.html",
    "title": "Overwrite Hosted Feature Layer",
    "section": "",
    "text": "From time to time as the owner of a Feature Layer, you may need to completely overwrite the data in the service. Overwriting a web layer from ArcGIS Pro may lead to a loss of associated pop-ups and symbology. One way to get around this is to truncate the feature service and append new data to the same service.\nFor this example, we need to be the owner of a Feature Service. As such, we will use the North Carolina SIDS dataset we created in the Publishing from R tutorial. If you have not done that tutorial, complete it first.",
    "crumbs": [
      "Editing",
      "Truncate and append features"
    ]
  },
  {
    "objectID": "docs/editing/overwrite-features.html#truncating-a-feature-layer",
    "href": "docs/editing/overwrite-features.html#truncating-a-feature-layer",
    "title": "Overwrite Hosted Feature Layer",
    "section": "Truncating a Feature Layer",
    "text": "Truncating a Feature Layer\nTruncating a Feature Layer deletes every single record in the service and resets the auto-increment of the object ID. Truncating a service does not change the field definitions or permit us to add or remove fields. If you wish to do so, publish a new layer instead.\nBefore we can modify a service, we must first authorize ourselves with the portal. To do so we will use the auth_code() authorization flow. If you have not yet configured you environment to authorize with your portal, follow the Connecting to your Portal tutorial.\nFirst load arcgis.\n\nlibrary(arcgis)\n\nAttaching core arcgis packages:\n  - {arcgisutils} v0.3.0\n  - {arcgislayers} v0.2.0\nNext, authorize with the portal and set the access token.\n\ntoken &lt;- auth_code()\nset_auth_token(token)\n\nToken set to environment variable `ARCGIS_TOKEN`\nNow that we have verified our identity with our portal we can create a FeatureLayer object in R from our hosted service. From your content listing find the Feature Layer url.\n\n\n\n\n\n\nTip\n\n\n\nRevisit the “Obtaining a feature layer url” section of the Read hosted data tutorial if you forgot how to retrieve the service url.\n\n\n\nfurl &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\"\n\nnc &lt;- arc_open(furl)\nnc\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n\n\nThis is the url of your hosted feature service. Yours will be different than the URL shown here. Note that the /0 indicates the layer index. You can often copy the url from under the URL section on the right hand menu and append the /0 to it.\nBefore we can truncate the FeatureLayer, we should check to see that the layer itself supports this operation. The supportsTruncate attribute will return TRUE if we can truncate it. If not, we’re out of luck and need to create an entirely new service!\n\nnc[[\"supportsTruncate\"]]\n\nSince we know that we can truncate the service, we can go ahead and do so.\n\ntruncate_res &lt;- truncate_layer(nc)\ntruncate_res\n\nWe store the result into truncate_res to see the results. Let’s now go ahead and refresh our layer and check to see if the changes have taken place.\n\nnc &lt;- refresh_layer(nc)\nnc\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCapabilities: Create,Delete,Query,Update,Editing\nAfter refreshing the layer we can see that there are now 0 features! Success! There are still 15 fields and we still have the same name and geometry type.",
    "crumbs": [
      "Editing",
      "Truncate and append features"
    ]
  },
  {
    "objectID": "docs/editing/overwrite-features.html#adding-features",
    "href": "docs/editing/overwrite-features.html#adding-features",
    "title": "Overwrite Hosted Feature Layer",
    "section": "Adding features",
    "text": "Adding features\nNow that we have deleted all of the features of the layer, lets go ahead and add some new ones. Let’s read the nc.shp file from sf into memory, give it a slight modification, and add those features to our service.\n\nlibrary(sf)\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\nnc_sf &lt;- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc_sf\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nRather than publish the polygons as they are, let’s calculate the convex hull of each shape and publish those.\n\nnc_convex &lt;- st_convex_hull(nc_sf)\nplot(st_geometry(nc_convex))\n\nLet’s take this sf object and add them as features to our now empty FeatureLayer. To add features, we use the add_features() function. The first argument is the FeatureLayer (or Table) that we are adding features to. The second is the sf object that we will be adding to the layer.\n\n\n\n\n\n\nTip\n\n\n\nIt is important to note that the column names of the sf object must match the names of the fields in the FeatureLayer, otherwise arcgis does not know which column matches which field.\n\n\n\nadd_res &lt;- add_features(nc, nc_convex)\n\nWarning: CRS missing from `x` cannot verify matching CRS.\nWe receive a warning because there is no spatial reference in the hosted FeatureLayer after truncating. Print the add_res object to see if each feature was successfully added.\n\nhead(add_res)\n\n    objectId uniqueId globalId success\n1          1        1       NA    TRUE\n2          2        2       NA    TRUE\n3          3        3       NA    TRUE\n4          4        4       NA    TRUE\n5          5        5       NA    TRUE\n6          6        6       NA    TRUE\nNow that we have added our features, let us refresh the layer again.\n\nnc &lt;- refresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nIf you view the hosted Feature Layer in the map viewer, you should now see the convex hulls.",
    "crumbs": [
      "Editing",
      "Truncate and append features"
    ]
  },
  {
    "objectID": "docs/geocode/forward-geocoding.html",
    "href": "docs/geocode/forward-geocoding.html",
    "title": "Forward Geocoding",
    "section": "",
    "text": "Forward geocoding is the process of taking an address or place information and identifying its location on the globe.\nTo geocode addresses, the {arcgisgeocode} package provides the function find_address_candidates(). This function geocodes a single address at a time and returns up to 50 address candidates (ranked by a score).\nThere are two ways in which you can provide address information:\n\nProvide the entire address as a string via the single_line argument\nProvide parts of the address using the arguments address, city, region, postal etc.\n\n\nSingle line address geocoding\nIt can be tough to parse out addresses into their components. Using the single_line argument is a very flexible way of geocoding addresses. Doing utilizes the ArcGIS World Geocoder’s address parsing capabilities.\nFor example, we can geocode the same location using 3 decreasingly specific addresses.\n\nlibrary(arcgisgeocode)\n\naddresses &lt;- c(\n  \"380 New York Street Redlands, California, 92373, USA\",\n  \"Esri Redlands\",\n  \"ESRI CA\"\n)\n\nlocs &lt;- find_address_candidates(\n  addresses,\n  max_locations = 1L\n)\n\nlocs$geometry\n\nGeometry set for 3 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -117.1948 ymin: 34.05726 xmax: -117.1948 ymax: 34.05726\nGeodetic CRS:  WGS 84\n\n\nPOINT (-117.1948 34.05726)\n\n\nPOINT (-117.1957 34.05609)\nPOINT (-117.1957 34.05609)\n\n\nIn each case, it finds the correct address!\n\n\nGeocoding from a dataframe\nMost commonly, you will need to geocode addresses from a column in a data.frame. It is important to note that the find_address_candidates() function does not work well in a dplyr::mutate() function call. Particularly because it is possible to return more than 1 address at a time.\nLet’s read in a csv of bike stores in Tacoma, WA. To use find_address_candidates() with a data.frame, it is recommended to create a unique identifier of the row positions.\n\nlibrary(dplyr)\n\nfp &lt;- \"https://www.arcgis.com/sharing/rest/content/items/9a9b91179ac44db1b689b42017471ae6/data\"\n\nbike_stores &lt;- readr::read_csv(fp) |&gt;\n  mutate(id = row_number())\n\nbike_stores\n\n# A tibble: 10 × 3\n   store_name                           original_address                      id\n   &lt;chr&gt;                                &lt;chr&gt;                              &lt;int&gt;\n 1 Cascadia Wheel Co.                   3320 N Proctor St, Tacoma, WA 984…     1\n 2 Puget Sound Bike and Ski Shop        between 3206 N. 15th and 1414, N …     2\n 3 Takoma Bike & Ski                    3010 6th Ave, Tacoma, WA 98406         3\n 4 Trek Bicycle Tacoma University Place 3550 Market Pl W Suite 102, Unive…     4\n 5 Opalescent Cyclery                   814 6th Ave, Tacoma, WA 98405          5\n 6 Sound Bikes                          108 W Main, Puyallup, WA 98371         6\n 7 Trek Bicycle Tacoma North End        3009 McCarver St, Tacoma, WA 98403     7\n 8 Second Cycle                         1205 M.L.K. Jr Way, Tacoma, WA 98…     8\n 9 Penny bike co.                       6419 24th St NE, Tacoma, WA 98422      9\n10 Spider's Bike, Ski & Tennis Lab      3608 Grandview St, Gig Harbor, WA…    10\n\n\nTo geocode addresses from a data.frame, you can use dplyr::reframe().\n\nbike_stores |&gt;\n  reframe(\n    find_address_candidates(original_address)\n  )\n\n# A tibble: 13 × 62\n   input_id result_id loc_name status score match_addr    long_label short_label\n      &lt;int&gt;     &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;      &lt;chr&gt;      \n 1        1        NA World    M      100   3320 N Proct… 3320 N Pr… 3320 N Pro…\n 2        2        NA World    M       97.6 N 15th St & … N 15th St… N 15th St …\n 3        2        NA World    M       97.3 1414 N Alder… 1414 N Al… 1414 N Ald…\n 4        2        NA World    M       94.7 S 15th St & … S 15th St… S 15th St …\n 5        2        NA World    M       84.4 3206 N 15th … 3206 N 15… 3206 N 15t…\n 6        3        NA World    M      100   3010 6th Ave… 3010 6th … 3010 6th A…\n 7        4        NA World    M      100   3550 Market … 3550 Mark… 3550 Marke…\n 8        5        NA World    M      100   814 6th Ave,… 814 6th A… 814 6th Ave\n 9        6        NA World    M      100   108 W Main, … 108 W Mai… 108 W Main \n10        7        NA World    M      100   3009 McCarve… 3009 McCa… 3009 McCar…\n11        8        NA World    M      100   1205 Martin … 1205 Mart… 1205 Marti…\n12        9        NA World    M       97.9 6419 24th St… 6419 24th… 6419 24th …\n13       10        NA World    M      100   3608 Grandvi… 3608 Gran… 3608 Grand…\n# ℹ 54 more variables: addr_type &lt;chr&gt;, type_field &lt;chr&gt;, place_name &lt;chr&gt;,\n#   place_addr &lt;chr&gt;, phone &lt;chr&gt;, url &lt;chr&gt;, rank &lt;dbl&gt;, add_bldg &lt;chr&gt;,\n#   add_num &lt;chr&gt;, add_num_from &lt;chr&gt;, add_num_to &lt;chr&gt;, add_range &lt;chr&gt;,\n#   side &lt;chr&gt;, st_pre_dir &lt;chr&gt;, st_pre_type &lt;chr&gt;, st_name &lt;chr&gt;,\n#   st_type &lt;chr&gt;, st_dir &lt;chr&gt;, bldg_type &lt;chr&gt;, bldg_name &lt;chr&gt;,\n#   level_type &lt;chr&gt;, level_name &lt;chr&gt;, unit_type &lt;chr&gt;, unit_name &lt;chr&gt;,\n#   sub_addr &lt;chr&gt;, st_addr &lt;chr&gt;, block &lt;chr&gt;, sector &lt;chr&gt;, nbrhd &lt;chr&gt;, …\n\n\nNotice how there are multiple results for each input_id. This is because the max_locations argument was not specified. To ensure only the best match is returned set max_locations = 1\n\ngeocoded &lt;- bike_stores |&gt;\n  reframe(\n    find_address_candidates(original_address, max_locations = 1)\n  ) |&gt;\n  # reframe drops the sf class, must be added\n  sf::st_as_sf()\n\ngeocoded\n\nSimple feature collection with 10 features and 61 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -122.5871 ymin: 47.19164 xmax: -122.294 ymax: 47.32301\nGeodetic CRS:  WGS 84\n# A tibble: 10 × 62\n   input_id result_id loc_name status score match_addr    long_label short_label\n      &lt;int&gt;     &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;      &lt;chr&gt;      \n 1        1        NA World    M      100   3320 N Proct… 3320 N Pr… 3320 N Pro…\n 2        2        NA World    M       97.6 N 15th St & … N 15th St… N 15th St …\n 3        3        NA World    M      100   3010 6th Ave… 3010 6th … 3010 6th A…\n 4        4        NA World    M      100   3550 Market … 3550 Mark… 3550 Marke…\n 5        5        NA World    M      100   814 6th Ave,… 814 6th A… 814 6th Ave\n 6        6        NA World    M      100   108 W Main, … 108 W Mai… 108 W Main \n 7        7        NA World    M      100   3009 McCarve… 3009 McCa… 3009 McCar…\n 8        8        NA World    M      100   1205 Martin … 1205 Mart… 1205 Marti…\n 9        9        NA World    M       97.9 6419 24th St… 6419 24th… 6419 24th …\n10       10        NA World    M      100   3608 Grandvi… 3608 Gran… 3608 Grand…\n# ℹ 54 more variables: addr_type &lt;chr&gt;, type_field &lt;chr&gt;, place_name &lt;chr&gt;,\n#   place_addr &lt;chr&gt;, phone &lt;chr&gt;, url &lt;chr&gt;, rank &lt;dbl&gt;, add_bldg &lt;chr&gt;,\n#   add_num &lt;chr&gt;, add_num_from &lt;chr&gt;, add_num_to &lt;chr&gt;, add_range &lt;chr&gt;,\n#   side &lt;chr&gt;, st_pre_dir &lt;chr&gt;, st_pre_type &lt;chr&gt;, st_name &lt;chr&gt;,\n#   st_type &lt;chr&gt;, st_dir &lt;chr&gt;, bldg_type &lt;chr&gt;, bldg_name &lt;chr&gt;,\n#   level_type &lt;chr&gt;, level_name &lt;chr&gt;, unit_type &lt;chr&gt;, unit_name &lt;chr&gt;,\n#   sub_addr &lt;chr&gt;, st_addr &lt;chr&gt;, block &lt;chr&gt;, sector &lt;chr&gt;, nbrhd &lt;chr&gt;, …\n\n\nWith this result, you can now join the address fields back onto the bike_stores data.frame using a left_join().\n\nleft_join(\n  bike_stores,\n  geocoded,\n  by = c(\"id\" = \"input_id\")\n) |&gt;\n  # left_join keeps the class of the first table\n  # must add sf class back on\n  sf::st_as_sf()\n\nSimple feature collection with 10 features and 63 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -122.5871 ymin: 47.19164 xmax: -122.294 ymax: 47.32301\nGeodetic CRS:  WGS 84\n# A tibble: 10 × 64\n   store_name  original_address    id result_id loc_name status score match_addr\n   &lt;chr&gt;       &lt;chr&gt;            &lt;int&gt;     &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;     \n 1 Cascadia W… 3320 N Proctor …     1        NA World    M      100   3320 N Pr…\n 2 Puget Soun… between 3206 N.…     2        NA World    M       97.6 N 15th St…\n 3 Takoma Bik… 3010 6th Ave, T…     3        NA World    M      100   3010 6th …\n 4 Trek Bicyc… 3550 Market Pl …     4        NA World    M      100   3550 Mark…\n 5 Opalescent… 814 6th Ave, Ta…     5        NA World    M      100   814 6th A…\n 6 Sound Bikes 108 W Main, Puy…     6        NA World    M      100   108 W Mai…\n 7 Trek Bicyc… 3009 McCarver S…     7        NA World    M      100   3009 McCa…\n 8 Second Cyc… 1205 M.L.K. Jr …     8        NA World    M      100   1205 Mart…\n 9 Penny bike… 6419 24th St NE…     9        NA World    M       97.9 6419 24th…\n10 Spider's B… 3608 Grandview …    10        NA World    M      100   3608 Gran…\n# ℹ 56 more variables: long_label &lt;chr&gt;, short_label &lt;chr&gt;, addr_type &lt;chr&gt;,\n#   type_field &lt;chr&gt;, place_name &lt;chr&gt;, place_addr &lt;chr&gt;, phone &lt;chr&gt;,\n#   url &lt;chr&gt;, rank &lt;dbl&gt;, add_bldg &lt;chr&gt;, add_num &lt;chr&gt;, add_num_from &lt;chr&gt;,\n#   add_num_to &lt;chr&gt;, add_range &lt;chr&gt;, side &lt;chr&gt;, st_pre_dir &lt;chr&gt;,\n#   st_pre_type &lt;chr&gt;, st_name &lt;chr&gt;, st_type &lt;chr&gt;, st_dir &lt;chr&gt;,\n#   bldg_type &lt;chr&gt;, bldg_name &lt;chr&gt;, level_type &lt;chr&gt;, level_name &lt;chr&gt;,\n#   unit_type &lt;chr&gt;, unit_name &lt;chr&gt;, sub_addr &lt;chr&gt;, st_addr &lt;chr&gt;, …",
    "crumbs": [
      "Geocoding",
      "Forward Geocoding"
    ]
  },
  {
    "objectID": "docs/geocode/bulk-geocoding.html",
    "href": "docs/geocode/bulk-geocoding.html",
    "title": "Bulk geocoding",
    "section": "",
    "text": "Bulk geocoding capabilities are provided via the geocode_addresses() function in {arcgisgeocode}. Rather geocoding a single address and returning match candidates, the bulk geocoding capabilities take many addresses and geocode them all at once returning a single location per address.\nUsing the bulk geocoding capabilities can result in incurring a cost. See more about geocoding pricing.\nIn this example, you will geocode restaurant addresses in Boston, MA collected by the Boston Area Research Initiative (BARI). The data is originally from their data portal.\n\nStep 1. Authenticate\nIn order to utilize the bulk geocoding capabilities of the ArcGIS World Geocoder, you must first authenticate using {arcgisutils}. In this example, we are using user-based authentication via auth_user(). You may choose a different authentication function if it works better for you.\n\nlibrary(arcgisutils)\nlibrary(arcgisgeocode)\n\nset_arc_token(auth_user())\n\n\n\nStep 2. Prepare the data\nSimilar to using find_address_candidates() the geocoding results return an ID that can be used to join back onto the original dataset. First, you will read in the dataset from a filepath using readr::read_csv() and then create a unique identifier with dplyr::mutate() and dplyr::row_number().\n\n# Boston Yelp addresses\n# Source: https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/DMWCBT\nfp &lt;- \"https://analysis-1.maps.arcgis.com/sharing/rest/content/items/0423768816b343b69d9a425b82351912/data\"\n\nlibrary(dplyr)\nrestaurants &lt;- readr::read_csv(fp) |&gt;\n  mutate(id = row_number())\n\nrestaurants\n\n# A tibble: 2,664 × 28\n   restaurant_name  restaurant_ID restaurant_address restaurant_tag rating price\n   &lt;chr&gt;                    &lt;dbl&gt; &lt;chr&gt;              &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 100% Delicias                2 635 Hyde Park Ave… Latin America…    2   $$   \n 2 100% Delicias E…             3 660A Centre St,Ja… Dominican,Emp…    4   &lt;NA&gt; \n 3 107                          4 107 Salem St,Bost… Restaurants,     NA   &lt;NA&gt; \n 4 140 Supper Club              6 138 St James Ave,… Diners,           5   &lt;NA&gt; \n 5 163 Vietnamese …             7 66 Harrison Ave,B… Vietnamese,Co…    3.5 $    \n 6 180 Cafe                     8 23 Edinboro St,Bo… Cafes,            4   &lt;NA&gt; \n 7 180 Restaurant …             9 174 Lincoln St,Bo… Restaurants,     NA   &lt;NA&gt; \n 8 224 Boston Stre…            11 224 Boston St,Dor… American (New…    4   $$   \n 9 24 Hour Pizza D…            12 686 Morton St,Bos… Pizza,            1   $$$$ \n10 2Twenty2                    13 222 Friend St,Bos… Asian Fusion,…    3   &lt;NA&gt; \n# ℹ 2,654 more rows\n# ℹ 22 more variables: review_number &lt;dbl&gt;, unique_reviewer &lt;dbl&gt;,\n#   reviews_Jan_19 &lt;dbl&gt;, reviews_Feb_19 &lt;dbl&gt;, reviews_Mar_19 &lt;dbl&gt;,\n#   reviews_Apr_19 &lt;dbl&gt;, reviews_May_19 &lt;dbl&gt;, reviews_Jun_19 &lt;dbl&gt;,\n#   reviews_Jul_19 &lt;dbl&gt;, reviews_Aug_19 &lt;dbl&gt;, reviews_Jan_20 &lt;dbl&gt;,\n#   reviews_Feb_20 &lt;dbl&gt;, reviews_Mar_20 &lt;dbl&gt;, reviews_Apr_20 &lt;dbl&gt;,\n#   reviews_May_20 &lt;dbl&gt;, reviews_Jun_20 &lt;dbl&gt;, reviews_Jul_20 &lt;dbl&gt;, …\n\n\n\n\nStep 3. Geocode addresses\nThe restaurant addresses are contained in the restaurant_address column. Pass this column into the single_line argument of geocode_addresses() and store the results in geocoded.\n\ngeocoded &lt;- geocode_addresses(\n  single_line = restaurants[[\"restaurant_address\"]]\n)\n\n# preview the first 10 columns\nglimpse(geocoded[, 1:10])\n\nRows: 2,664\nColumns: 11\n$ result_id   &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,…\n$ loc_name    &lt;chr&gt; \"World\", \"World\", \"World\", \"World\", \"World\", \"World\", \"Wor…\n$ status      &lt;chr&gt; \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\"…\n$ score       &lt;dbl&gt; 100.00, 100.00, 100.00, 100.00, 100.00, 100.00, 100.00, 10…\n$ match_addr  &lt;chr&gt; \"635 Hyde Park Avenue, Roslindale, Massachusetts, 02131\", …\n$ long_label  &lt;chr&gt; \"635 Hyde Park Avenue, Roslindale, MA, 02131, USA\", \"660A …\n$ short_label &lt;chr&gt; \"635 Hyde Park Avenue\", \"660A Centre Street\", \"107\", \"138 …\n$ addr_type   &lt;chr&gt; \"PointAddress\", \"PointAddress\", \"POI\", \"PointAddress\", \"Po…\n$ type_field  &lt;chr&gt; NA, NA, \"Bank\", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ place_name  &lt;chr&gt; NA, NA, \"107\", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ geometry    &lt;POINT [°]&gt; POINT (-71.11936 42.27857), POINT (-71.11386 42.3128…\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can use dplyr::reframe() to geocode these addresses in a dplyr-friendly way.\n\n\n\n\nStep 4. Join the results\nIn the previous step you geocoded the addresses and returned a data frame containing the location information. More likely than not, it would be helpful to have the locations joined onto the original dataset. You can do this by using dplyr::left_join() and joining on the id column you created and the result_id from the geocoding results.\n\njoined_addresses &lt;- left_join(\n  restaurants,\n  geocoded,\n  by = c(\"id\" = \"result_id\")\n)\n\ndplyr::glimpse(joined_addresses)\n\nRows: 2,664\nColumns: 87\n$ restaurant_name         &lt;chr&gt; \"100% Delicias\", \"100% Delicias Express\", \"107…\n$ restaurant_ID           &lt;dbl&gt; 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 16, 17, 18, 2…\n$ restaurant_address      &lt;chr&gt; \"635 Hyde Park Ave,Roslindale, MA 02131,\", \"66…\n$ restaurant_tag          &lt;chr&gt; \"Latin American,Dominican,\", \"Dominican,Empana…\n$ rating                  &lt;dbl&gt; 2.0, 4.0, NA, 5.0, 3.5, 4.0, NA, 4.0, 1.0, 3.0…\n$ price                   &lt;chr&gt; \"$$\", NA, NA, NA, \"$\", NA, NA, \"$$\", \"$$$$\", N…\n$ review_number           &lt;dbl&gt; 37, 26, 0, 1, 335, 8, 0, 248, 31, 63, 10, 232,…\n$ unique_reviewer         &lt;dbl&gt; 34, 25, 0, 1, 335, 8, 0, 248, 31, 63, 10, 232,…\n$ reviews_Jan_19          &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 1, 0, 8, 0, 1, 7, 0, 1, 0…\n$ reviews_Feb_19          &lt;dbl&gt; 1, 2, 0, 0, 0, 0, 0, 4, 0, 3, 0, 0, 2, 0, 0, 0…\n$ reviews_Mar_19          &lt;dbl&gt; 1, 3, 0, 0, 0, 1, 0, 5, 1, 2, 0, 0, 3, 0, 2, 0…\n$ reviews_Apr_19          &lt;dbl&gt; 0, 3, 0, 0, 1, 0, 0, 3, 0, 4, 0, 3, 5, 0, 0, 0…\n$ reviews_May_19          &lt;dbl&gt; 2, 1, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 6, 0, 0, 0…\n$ reviews_Jun_19          &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 1, 3, 0, 0, 0…\n$ reviews_Jul_19          &lt;dbl&gt; 0, 1, 0, 0, 3, 1, 0, 4, 1, 0, 4, 0, 3, 0, 2, 0…\n$ reviews_Aug_19          &lt;dbl&gt; 0, 7, 0, 0, 0, 0, 0, 3, 0, 7, 3, 0, 0, 0, 0, 0…\n$ reviews_Jan_20          &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 5, 1, 0, 0…\n$ reviews_Feb_20          &lt;dbl&gt; 0, 1, 0, 0, 1, 0, 0, 2, 0, 2, 1, 3, 8, 6, 0, 0…\n$ reviews_Mar_20          &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 6, 0, 0…\n$ reviews_Apr_20          &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0…\n$ reviews_May_20          &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0…\n$ reviews_Jun_20          &lt;dbl&gt; 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 6, 0, 0…\n$ reviews_Jul_20          &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 3, 0…\n$ reviews_Aug_20          &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 4, 1, 0…\n$ restaurant_neighborhood &lt;chr&gt; \"Roslindale\", \"Jamaica Plain\", \"Boston\", \"Bost…\n$ GIS_ID                  &lt;dbl&gt; 1806741000, 1901410000, 302366000, 401087000, …\n$ CT_ID_10                &lt;dbl&gt; 25025140400, 25025120400, 25025030400, 2502501…\n$ id                      &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,…\n$ loc_name                &lt;chr&gt; \"World\", \"World\", \"World\", \"World\", \"World\", \"…\n$ status                  &lt;chr&gt; \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"…\n$ score                   &lt;dbl&gt; 100.00, 100.00, 100.00, 100.00, 100.00, 100.00…\n$ match_addr              &lt;chr&gt; \"635 Hyde Park Avenue, Roslindale, Massachuset…\n$ long_label              &lt;chr&gt; \"635 Hyde Park Avenue, Roslindale, MA, 02131, …\n$ short_label             &lt;chr&gt; \"635 Hyde Park Avenue\", \"660A Centre Street\", …\n$ addr_type               &lt;chr&gt; \"PointAddress\", \"PointAddress\", \"POI\", \"PointA…\n$ type_field              &lt;chr&gt; NA, NA, \"Bank\", NA, NA, NA, NA, NA, NA, NA, NA…\n$ place_name              &lt;chr&gt; NA, NA, \"107\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ place_addr              &lt;chr&gt; \"635 Hyde Park Avenue, Roslindale, Massachuset…\n$ phone                   &lt;chr&gt; NA, NA, \"(617) 227-6236\", NA, NA, NA, NA, NA, …\n$ url                     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ rank                    &lt;dbl&gt; 20, 20, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20…\n$ add_bldg                &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ add_num                 &lt;chr&gt; \"635\", \"660A\", \"107\", \"138\", \"66\", \"23\", \"174\"…\n$ add_num_from            &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ add_num_to              &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ add_range               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ side                    &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ st_pre_dir              &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ st_pre_type             &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ st_name                 &lt;chr&gt; \"Hyde Park\", \"Centre\", \"Salem\", \"Saint James\",…\n$ st_type                 &lt;chr&gt; \"Avenue\", \"Street\", \"St\", \"Avenue\", \"Avenue\", …\n$ st_dir                  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ bldg_type               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ bldg_name               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ level_type              &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ level_name              &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ unit_type               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ unit_name               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ sub_addr                &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ st_addr                 &lt;chr&gt; \"635 Hyde Park Avenue\", \"660A Centre Street\", …\n$ block                   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ sector                  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ nbrhd                   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ district                &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ city                    &lt;chr&gt; \"Roslindale\", \"Jamaica Plain\", \"Boston\", \"Bost…\n$ metro_area              &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ subregion               &lt;chr&gt; \"Suffolk County\", \"Suffolk County\", \"Suffolk C…\n$ region                  &lt;chr&gt; \"Massachusetts\", \"Massachusetts\", \"Massachuset…\n$ region_abbr             &lt;chr&gt; \"MA\", \"MA\", \"MA\", \"MA\", \"MA\", \"MA\", \"MA\", \"MA\"…\n$ territory               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ zone                    &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ postal                  &lt;chr&gt; \"02131\", \"02130\", \"02113\", \"02116\", \"02111\", \"…\n$ postal_ext              &lt;chr&gt; \"4723\", NA, NA, \"5071\", \"1907\", \"2131\", \"2404\"…\n$ country                 &lt;chr&gt; \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA…\n$ cntry_name              &lt;chr&gt; \"United States\", \"United States\", \"United Stat…\n$ lang_code               &lt;chr&gt; \"ENG\", \"ENG\", \"ENG\", \"ENG\", \"ENG\", \"ENG\", \"ENG…\n$ distance                &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ x                       &lt;dbl&gt; -71.11936, -71.11386, -71.05537, -71.07624, -7…\n$ y                       &lt;dbl&gt; 42.27857, 42.31285, 42.36419, 42.34923, 42.351…\n$ display_x               &lt;dbl&gt; -71.11936, -71.11386, -71.05537, -71.07624, -7…\n$ display_y               &lt;dbl&gt; 42.27857, 42.31285, 42.36419, 42.34923, 42.351…\n$ xmin                    &lt;dbl&gt; -71.12036, -71.11486, -71.05637, -71.07724, -7…\n$ xmax                    &lt;dbl&gt; -71.11836, -71.11286, -71.05437, -71.07524, -7…\n$ ymin                    &lt;dbl&gt; 42.27757, 42.31185, 42.36319, 42.34823, 42.350…\n$ ymax                    &lt;dbl&gt; 42.27957, 42.31385, 42.36519, 42.35023, 42.352…\n$ ex_info                 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ geometry                &lt;POINT [°]&gt; POINT (-71.11936 42.27857), POINT (-71.1…",
    "crumbs": [
      "Geocoding",
      "Bulk Geocoding"
    ]
  },
  {
    "objectID": "docs/get-started.html",
    "href": "docs/get-started.html",
    "title": "Get started",
    "section": "",
    "text": "The R-ArcGIS Bridge supports working with both ArcGIS Pro as well as ArcGIS location services.",
    "crumbs": [
      "Get started"
    ]
  },
  {
    "objectID": "docs/get-started.html#install-the-r-packages",
    "href": "docs/get-started.html#install-the-r-packages",
    "title": "Get started",
    "section": "Install the R packages",
    "text": "Install the R packages\nTo install the packages run:\ninstall.packages(\"arcgis\")\nOnce the installation has finished you can load all of the packages using\nlibrary(arcgis)\nOr, you can install the packages individually as well by running:\npkgs &lt;- c(\"arcgisutils\", \"arcgislayers\", \"arcgisgeocode\", \"arcgisplaces\")\n\ninstall.packages(pkgs)",
    "crumbs": [
      "Get started"
    ]
  },
  {
    "objectID": "docs/get-started.html#learn-more",
    "href": "docs/get-started.html#learn-more",
    "title": "Get started",
    "section": "Learn more",
    "text": "Learn more\n\nReading Data\nPublishing\nGeocoding\nPlaces services (POI data)",
    "crumbs": [
      "Get started"
    ]
  },
  {
    "objectID": "docs/get-started.html#learn-more-1",
    "href": "docs/get-started.html#learn-more-1",
    "title": "Get started",
    "section": "Learn more",
    "text": "Learn more\n\nInstalling {arcgisbinding}\nCreating geoprocessing tools",
    "crumbs": [
      "Get started"
    ]
  },
  {
    "objectID": "location-services/tutorials/shiny-dash/index.html",
    "href": "location-services/tutorials/shiny-dash/index.html",
    "title": "Dashboard using {arcgis}",
    "section": "",
    "text": "In this tutorial we will be recreating a dashboard that utilizes the data from the City of Chattanooga Open Data Portal. In the below LinkedIn post by Charlie Mix, GIS Director at the University of Tennessee at Chattanooga IGTLab, they use this data to create an ArcGIS Dashboard.\nOriginal LinkedIn Post\nThe data is provided as a Feature Service by Charlie Mix, which we will use to create a lightweight interactive dashboard in R using {arcgis} and additional R packages.\nThe dashboard that we are going to create can be viewed live here."
  },
  {
    "objectID": "location-services/tutorials/shiny-dash/index.html#the-packages",
    "href": "location-services/tutorials/shiny-dash/index.html#the-packages",
    "title": "Dashboard using {arcgis}",
    "section": "The Packages",
    "text": "The Packages\nThere are 4 components to this dashboard that we will want to recreate. These are the two plots, the statistics, and the map. In this tutorial we will not create an exact replica, but one in spirit.\nIn addition to arcgis we will use a number of other packages to make this happen some may be new to you:\n\nsf: spatial data manipulation\nbslib: create the UI\ndplyr: basic data manipulation\narcgis: interact with feature services\nplotly: interactive plots\nbsicons: icons for our UI\nggplot2: create plots\nleaflet: create interactive maps\n\n\nlibrary(sf)\nlibrary(bslib)\n\n#&gt; Warning: package 'bslib' was built under R version 4.3.1\n\nlibrary(dplyr)\nlibrary(arcgis)\nlibrary(plotly)\nlibrary(bsicons)\nlibrary(ggplot2)\nlibrary(leaflet)"
  },
  {
    "objectID": "location-services/tutorials/shiny-dash/index.html#reading-data-from-arcgis-online",
    "href": "location-services/tutorials/shiny-dash/index.html#reading-data-from-arcgis-online",
    "title": "Dashboard using {arcgis}",
    "section": "Reading data from ArcGIS Online",
    "text": "Reading data from ArcGIS Online\nThe very first step we will take in creating this dashboard is to read in the data from the hosted Feature Services. To do so, we will use the function arc_open() from arcgislayers.\n\ndata_url &lt;- \"https://services.arcgis.com/UnTXoPXBYERF0OH6/arcgis/rest/services/Vehicle_Pedestrian_Incidents/FeatureServer\"\n\n# open the feature server\ncrash_server &lt;- arc_open(data_url)\ncrash_server\n\n#&gt; &lt;FeatureServer &lt;2 layers, 0 tables&gt;&gt;\n#&gt; CRS: 32136\n#&gt; Capabilities: Query\n#&gt;   1: Vehicle Pedestrian Incidents (esriGeometryPoint)\n#&gt;   2: Vehicle Pedestrian Incidents OptimizedHotSpotAnalysis (esriGeometryPolygon)\n\n\nThe url that we provided was to a Feature Server which contains two layers in it. To access these, we can use the get_layer() function and provide the index of the layer we want. We’ll do this and store the FeatureLayers as the object incidents and hotspots.\n\n# fetch individual layers\n(incidents &lt;- get_layer(crash_server, 1))\n\n#&gt; &lt;FeatureLayer&gt;\n#&gt; Name: Vehicle Pedestrian Incidents\n#&gt; Geometry Type: esriGeometryPoint\n#&gt; CRS: 32136\n#&gt; Capabilities: Query\n\n(hotspots &lt;- get_layer(crash_server, 2))\n\n#&gt; &lt;FeatureLayer&gt;\n#&gt; Name: Vehicle Pedestrian Incidents OptimizedHotSpotAnalysis\n#&gt; Geometry Type: esriGeometryPolygon\n#&gt; CRS: 32136\n#&gt; Capabilities: Query\n\n\nSince these are very small datasets (1000 features, exactly), we can bring them into memory and interact with them as sf objects directly without a concern for memory usage.\n\n\n\n\n\n\nTip\n\n\n\nFor larger datasets, we want to be cautious with how much data we bring into memory and only use what is needed at a time.\n\n\n\n# bring them into memory as sf objects\ninci_sf &lt;- arc_select(incidents)\nhs_sf &lt;- arc_select(hotspots)\n\nLet’s preview the data using dplyr::glimpse().\n\nHot Spot AnalysisIncidents\n\n\n\nglimpse(hs_sf)\n\n#&gt; Rows: 369\n#&gt; Columns: 10\n#&gt; $ OBJECTID      &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1…\n#&gt; $ SOURCE_ID     &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1…\n#&gt; $ JOIN_COUNT    &lt;int&gt; 2, 1, 1, 1, 1, 2, 1, 6, 1, 3, 1, 1, 1, 3, 1, 3, 1, 2, 1,…\n#&gt; $ GiZScore      &lt;dbl&gt; -0.40186687, -0.40186687, -0.40186687, -0.61763312, 0.76…\n#&gt; $ GiPValue      &lt;dbl&gt; 0.6877820, 0.6877820, 0.6877820, 0.5368172, 0.4431177, 0…\n#&gt; $ NNeighbors    &lt;int&gt; 3, 3, 3, 2, 10, 14, 14, 14, 7, 6, 21, 13, 6, 22, 24, 23,…\n#&gt; $ Gi_Bin        &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#&gt; $ Shape__Area   &lt;dbl&gt; 115843.3, 115848.0, 115857.5, 115909.8, 115924.1, 115933…\n#&gt; $ Shape__Length &lt;dbl&gt; 1266.954, 1266.979, 1267.031, 1267.318, 1267.396, 1267.4…\n#&gt; $ geometry      &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((668610.5 95..., MULTIPOLYGO…\n\n\n\n\n\nglimpse(inci_sf)\n\n#&gt; Rows: 631\n#&gt; Columns: 32\n#&gt; $ OBJECTID                    &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,…\n#&gt; $ Incident_Number             &lt;chr&gt; \"23-008820\", \"22-130607\", \"22-108023\", \"23…\n#&gt; $ Incident_Date               &lt;dttm&gt; 2023-01-25 18:00:00, 2022-12-03 18:02:00,…\n#&gt; $ Time_Num                    &lt;dbl&gt; 18.0, 18.0, 17.5, 1.5, 12.5, 20.5, 18.5, 9…\n#&gt; $ Street                      &lt;chr&gt; \"E 11th St\", \"2000 S Kelley St\", \"Dodds Av…\n#&gt; $ Alt_Street                  &lt;chr&gt; NA, NA, NA, NA, NA, \"US-11\", NA, NA, NA, \"…\n#&gt; $ City                        &lt;chr&gt; \"Chattanooga\", \"Chattanooga\", \"Chattanooga…\n#&gt; $ County                      &lt;chr&gt; \"Hamilton\", \"Hamilton\", \"Hamilton\", \"Hamil…\n#&gt; $ Intersection                &lt;chr&gt; \"Market St\", \"E 23rd Street\", \"E 41st St\",…\n#&gt; $ Mile_Post                   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n#&gt; $ Accident_Type               &lt;chr&gt; \"Possible Injury\", \"Property Damage Under\"…\n#&gt; $ Collision_Type              &lt;chr&gt; \"Not Collision with Motor Vehicle in Trans…\n#&gt; $ Hit_and_Run                 &lt;chr&gt; \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", …\n#&gt; $ Involved_Fatal_Injury       &lt;chr&gt; \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", …\n#&gt; $ Involved_Medical_Transport  &lt;chr&gt; \"No\", \"No\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"N…\n#&gt; $ Involved_Placarded_Truck    &lt;chr&gt; \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", …\n#&gt; $ Posted_Speed                &lt;int&gt; 25, 20, 40, 30, 45, 45, 15, NA, 35, 45, 40…\n#&gt; $ Total_Vehicles_Involved     &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n#&gt; $ Weather_Code                &lt;chr&gt; \"Clear\", \"Clear\", \"Clear\", \"Clear\", \"Clear…\n#&gt; $ Pedestrian_Involved         &lt;chr&gt; \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", …\n#&gt; $ Bicycle_Involved            &lt;chr&gt; \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", …\n#&gt; $ Drug_Involved               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n#&gt; $ Alcohol_Involved            &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n#&gt; $ Light_Condition             &lt;chr&gt; \"Dark - Lighted\", \"Dark - Lighted\", \"Dayli…\n#&gt; $ Driver_One_Safety_Equipment &lt;chr&gt; \"Unknown\", \"Unknown\", \"Unknown\", \"Unknown\"…\n#&gt; $ Driver_One_Zip              &lt;chr&gt; \"37411\", \"37403\", \"37421\", \"37421\", \"37404…\n#&gt; $ Driver_Two_Safety_Equipment &lt;chr&gt; \"Shoulder and Lap Belt Used\", \"Shoulder an…\n#&gt; $ Driver_Two_Zip              &lt;chr&gt; \"30755\", \"37406\", \"37407\", \"37341\", \"32148…\n#&gt; $ Latitude                    &lt;dbl&gt; 35.04283, 35.01957, 34.99520, 35.08057, 35…\n#&gt; $ Longitude                   &lt;dbl&gt; -85.31865, -85.27885, -85.28440, -85.26217…\n#&gt; $ Location_WKT                &lt;chr&gt; \"POINT (-85.318653 35.0428324)\", \"POINT (-…\n#&gt; $ geometry                    &lt;POINT [m]&gt; POINT (662169.1 78935.9), POINT (665…"
  },
  {
    "objectID": "location-services/tutorials/shiny-dash/index.html#creating-the-plots",
    "href": "location-services/tutorials/shiny-dash/index.html#creating-the-plots",
    "title": "Dashboard using {arcgis}",
    "section": "Creating the plots",
    "text": "Creating the plots\nNext, we will recreate the charts that were used in the original dashboard using the packages ggplot2 and plotly There are two plots that we will need to create. The first is the total number of incidents annually.\nBefore we can make the plots, we need to calculate the annual counts and store them in their own data.frame.\nHere we drop the geometry from the inci_sf sf object by using st_drop_geometry(). Next, we use the function lubridate::year() to extract the year as an integer from a date vector. Lastly, we dplyr::count() the number of observations per year.\n\n# set the theme that we will use\ntheme_set(theme_minimal())\n\nannual_counts &lt;- inci_sf |&gt;\n  st_drop_geometry() |&gt;\n  mutate(year = lubridate::year(Incident_Date)) |&gt;\n  count(year)\n\nannual_counts\n\n#&gt;   year   n\n#&gt; 1 2018  91\n#&gt; 2 2019  98\n#&gt; 3 2020  85\n#&gt; 4 2021 116\n#&gt; 5 2022 129\n#&gt; 6 2023 112\n\n\n\n\nWe drop the geometry because it is not needed for the calculation. If you include the geometry, they will be unioned which can be computationally intensive and time consuming.\nFrom this we can create a basic line plot using ggplot().\n\n\n\n\n\n\nNote\n\n\n\nIf you are unfamiliar with the basics of ggplot2 and dplyr, consider starting with R for Data Science\n\n\n\ngg_annual &lt;- ggplot(annual_counts, aes(year, n)) +\n  geom_line() +\n  geom_point(size = 3) +\n  labs(\n    x = \"Year\",\n    y = \"Incidents\"\n  )\n\nWe’ll take a similar approach for for counting the number of incidents based on the Posted_Speed column. Rather than counting based on the year we count based on the number of observations per unique value of Posted_Speed. We then remove the count of missing values.\nspeed_counts &lt;- inci_sf |&gt;\n  st_drop_geometry() |&gt;\n  count(Posted_Speed) |&gt;\n  filter(!is.na(Posted_Speed))\n\ngg_speed &lt;- ggplot(speed_counts, aes(Posted_Speed, n)) +\n  geom_col() +\n  labs(\n    x = \"Posted Speed Limit (miles per hour)\",\n    y = \"Incidents\"\n  )\n\ngg_annual\ngg_speed\n\n\n\n\n\n\n\n\n\n\nAchieving interactivity is a breeze with the function plotly::ggplotly().\nggplotly(gg_annual)\nggplotly(gg_speed)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlots UI components\nNow that we have defined our interactive plots, we can begin to create our first dashboard component with **bslib**.\nbslib lets us create html directly in R and provides many functions to create well designed components. In our dashboard we will include our plots in their own navigable tabs. To do so we will use the navset_card_tab() function. Each tab in the “navset” is defined by a nav_panel(). Here we can scaffold the navset and see what it looks like with no contents.\n\nnavset_card_tab(\n  title = \"Plots\",\n  nav_panel(\n    title = \"By year\"\n  ),\n  nav_panel(\n    title = \"By speed\"\n  )\n)\n\n\n\nPlots\n\n\nBy year\n\n\nBy speed\n\n\n\n\n\n\n\n\n\n\n\nNext, let’s include the plots in the nav_panel()s. We add the a title using card_title() and then include the plotly widget directly for each plot. We’ll save the component into an object called plot_tab which we will use later on.\n\nplot_tab &lt;- navset_card_tab(\n  title = \"Plots\",\n  nav_panel(\n    \"By year\",\n    card_title(\"Vehicle-Pedestrian Incidents by Year\"),\n    ggplotly(gg_annual)\n  ),\n  nav_panel(\n    \"By speed\",\n    card_title(\"Vehicle Pedestrian Incidents by Posted Speed Limit\"),\n    ggplotly(gg_speed)\n  )\n)\n\nplot_tab\n\n\n\nPlots\n\n\nBy year\n\n\nBy speed\n\n\n\n\n\n\nVehicle-Pedestrian Incidents by Year\n\n\n\n\n\n\nVehicle Pedestrian Incidents by Posted Speed Limit"
  },
  {
    "objectID": "location-services/tutorials/shiny-dash/index.html#statistic-value-boxes",
    "href": "location-services/tutorials/shiny-dash/index.html#statistic-value-boxes",
    "title": "Dashboard using {arcgis}",
    "section": "Statistic value boxes",
    "text": "Statistic value boxes\nNext, we will replicate the statistics boxes and add a bit of flair. To do so, we need to calculate the counts. This will be a lot like the approach we took above for calculating the number of incidents by year and speed. Below two approaches are provided. The dplyr approach uses another function dplyr::pull() which will extract a column into its underlying vector.\n\ndplyrBase R\n\n\n\nn_incidents &lt;- count(inci_sf) |&gt; \n  pull(n)\n\nn_medical_transit &lt;- inci_sf |&gt; \n  count(Involved_Medical_Transport) |&gt; \n  filter(Involved_Medical_Transport == \"Yes\") |&gt; \n  pull(n)\n\nn_fatalities &lt;- inci_sf |&gt; \n  count(Involved_Fatal_Injury) |&gt; \n  filter(Involved_Fatal_Injury == \"Yes\") |&gt; \n  pull(n)\n\nn_alc_drug &lt;- inci_sf |&gt; \n  filter(Drug_Involved == \"Yes\" | Alcohol_Involved == \"Yes\") |&gt; \n  count() |&gt; \n  pull(n)\n\n\n\n\nn_incidents &lt;- nrow(inci_sf)\n\nn_medical_transit &lt;- table(inci_sf$Involved_Medical_Transport)[\"Yes\"]\n\nn_fatalities &lt;- table(inci_sf$Involved_Fatal_Injury)[[\"Yes\"]]\n\nn_alc_drug &lt;- sum(\n  inci_sf$Drug_Involved == \"Yes\" | inci_sf$Alcohol_Involved == \"Yes\", \n  na.rm = TRUE\n)\n\n\n\n\nTo create the boxes we will utilize bslib::value_box(). For example\n\nvalue_box(\"Number of Incidents\", n_incidents)\n\n\n\n\nNumber of Incidents\n631\n\n\n\n\n\n\nThe showcase argument lets us add text or images that are emphasized in the value box. Let’s use bootstrap icons to add a bit of flair.\n\nvalue_box(\n    \"Number of Incidents\",\n    n_incidents,\n    showcase = bs_icon(\"person\")\n)\n\n\n\n\n\n\nNumber of Incidents\n631\n\n\n\n\n\n\n\nLet’s create a card for each of these statistics and store them in their own variable.\n\ninci_card &lt;- value_box(\n  \"Number of Incidents\",\n  n_incidents,\n  showcase = bs_icon(\"person\")\n)\n\nfatalities_card &lt;- value_box(\n  \"Total Fatalities\",\n  n_fatalities,\n  showcase = bs_icon(\"heartbreak\")\n)\n\nmedical_card &lt;- value_box(\n  \"Involved Medical Transport\",\n  n_medical_transit,\n  showcase = bs_icon(\"heart-pulse\")\n)\n\ndrugs_card &lt;- value_box(\n  \"Involved Drugs or Alcohol\",\n  n_alc_drug,\n  showcase = bs_icon(\"capsule\")\n)\n\nNext, we will build out another component of our dashboard from these cards. We’ll create a grid of these 4 using bslib::layout_columns(). This will arrange bslib components into columns for us.\n\nlayout_columns(\n  inci_card, \n  fatalities_card,\n  medical_card, \n  drugs_card\n)\n\n\n\n\n\n\n\n\nNumber of Incidents\n631\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Fatalities\n40\n\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Medical Transport\n381\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Drugs or Alcohol\n36\n\n\n\n\n\n\n\n\n\nBy default this will put each item in their own column. But we can specify the width of each element in grid units. In web development, user interfaces are often partitioned into grid units that are broken into twelve units. So if we want two value cards per row, we need to specify the column widths to be 6.\n\nstats &lt;- layout_columns(\n  inci_card, \n  fatalities_card,\n  medical_card, \n  drugs_card,\n  col_widths = 6\n)\n\nstats\n\n\n\n\n\n\n\n\nNumber of Incidents\n631\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Fatalities\n40\n\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Medical Transport\n381\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Drugs or Alcohol\n36"
  },
  {
    "objectID": "location-services/tutorials/shiny-dash/index.html#creating-the-map",
    "href": "location-services/tutorials/shiny-dash/index.html#creating-the-map",
    "title": "Dashboard using {arcgis}",
    "section": "Creating the map",
    "text": "Creating the map\nHaving created two of the three component of our dashboard, let’s take on the most challenging one: the map. We will use leaflet to create the map itself. However, for the sake of simplicity we will only be visualizing the hot spots and not adding in further interactivity such as pop-ups. Or the location of individual incidents.\nFirst let’s create a vector of Hot Spot Analysis result labels called gi_labels.\n\n\nHot Spot Analysis works by calculating a statistic called the Gi* (gee-eye-star).\n\n# create labels vector to pass to leaflet\ngi_labels &lt;- c(\n  \"Not Significant\",\n  \"Hot Spot with 90% Confidence\",\n  \"Hot Spot with 95% Confidence\",\n  \"Hot Spot with 99% Confidence\"\n)\n\nWe’ll translate the Gi_Bin values to labels using the dplyr::case_when() function which lets us evaluate logical statements and when they evaluate to true, assign a value.\nSince we will be using leaflet we will also need to use WGS84 coordinate system. We can use st_transform() to transform the geometry.\n\nhexes &lt;- hs_sf |&gt;\n  transmute(\n    classification = case_when(\n      Gi_Bin == 0 ~ gi_labels[1],\n      Gi_Bin == 1 ~ gi_labels[2],\n      Gi_Bin == 2 ~ gi_labels[3],\n      Gi_Bin == 3 ~ gi_labels[4]\n    )\n  ) |&gt;\n  st_transform(4326)\n\nIn order to modify the symbology used by leaflet, we need to create a color palette ourselves. For this, we will use the colorFactor() function. We need to provide it with two arguments. The first argument will be a character vector of color codes. The second argument levels, is also a character vector of the same length as the palette argument. The colors match the levels by position.\n\npal &lt;- colorFactor(\n  palette = c(\"#c6c6c3\", \"#c8976e\", \"#be6448\", \"#af3129\"),\n  levels = gi_labels\n)\n\nWith all of this, we can create our map in one chain. There’s a lot going on here, but if you run it step by step, it’ll be quite clear.\nFirst, we instantiate a leaflet map using leaflet(). Then, we add tiles (a base map) using addProviderTiles(). Following, we add our hexes object to the map using the addPolygons() function, add a legend with addLegend(). Lastly, we set an initial viewport location with the setView() function.\n\nmap &lt;- leaflet() |&gt;\n  addProviderTiles(\"Esri.WorldGrayCanvas\") |&gt;\n  addPolygons(\n    data = hexes,\n    fillColor = ~pal(classification),\n    color = \"#c6c6c3\",\n    weight = 1,\n    fillOpacity = 0.8\n  ) |&gt;\n  addLegend(\n    pal = pal,\n    values = gi_labels,\n    opacity = 1,\n    title = \"Hot Spot Classification\"\n  ) |&gt;\n  setView(-85.3, 35.04, 12.5)\n\nmap\n\n\n\n\n\nTo simplify our dashboard creation later, we can put this map into a bslib component with bslib::card(). We will give it a proper title as well with bslib::card_header().\n\nmap_card &lt;- card(\n  card_header(\"Vehicle-Pedestrian Incidents for Chattanooga, TN (2018-2023)\"),\n  map\n)\n\nmap_card\n\n\nVehicle-Pedestrian Incidents for Chattanooga, TN (2018-2023)"
  },
  {
    "objectID": "location-services/tutorials/shiny-dash/index.html#putting-the-ui-together",
    "href": "location-services/tutorials/shiny-dash/index.html#putting-the-ui-together",
    "title": "Dashboard using {arcgis}",
    "section": "Putting the UI together",
    "text": "Putting the UI together\nCreate an empty page with bslib::page_fillable(). We can add all of our elements directly to this page.\n\npage_fillable(\n  theme = theme_bootswatch(\"darkly\"),\n  map_card, stats, plot_tab\n)\n\n\n\nVehicle-Pedestrian Incidents for Chattanooga, TN (2018-2023)\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of Incidents\n631\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Fatalities\n40\n\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Medical Transport\n381\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Drugs or Alcohol\n36\n\n\n\n\n\n\n\n\n\nPlots\n\n\nBy year\n\n\nBy speed\n\n\n\n\n\n\nVehicle-Pedestrian Incidents by Year\n\n\n\n\n\n\nVehicle Pedestrian Incidents by Posted Speed Limit\n\n\n\n\n\n\n\n\n\n\nBut they are all squished together and it isn’t much of a dashboard. We can use the bslib::layout_columns() function to begin to arrange this a bit more. Let’s first get our right hand side of the dashboard arranged into its own layout so that the statistics sit above the plots.\nWe’ll set the col_widths = 12 so that each component takes the full width.\n\nrhs_col &lt;- layout_columns(\n  stats,\n  plot_tab,\n  col_widths = 12\n)\n\nrhs_col\n\n\n\n\n\n\n\n\n\n\nNumber of Incidents\n631\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Fatalities\n40\n\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Medical Transport\n381\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Drugs or Alcohol\n36\n\n\n\n\n\n\n\n\n\n\n\nPlots\n\n\nBy year\n\n\nBy speed\n\n\n\n\n\n\nVehicle-Pedestrian Incidents by Year\n\n\n\n\n\n\nVehicle Pedestrian Incidents by Posted Speed Limit\n\n\n\n\n\n\n\n\n\n\n\nNow that we have the right hand side sorted out, let’s create another layout_columns() where the map takes up 2/3 of the screen and the right hand column takes up the rest of the space.\n\ndash_content &lt;- layout_columns(\n  map_card,\n  rhs_col,\n  col_widths = c(8, 4)\n)\n\ndash_content\n\n\n\n\nVehicle-Pedestrian Incidents for Chattanooga, TN (2018-2023)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of Incidents\n631\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Fatalities\n40\n\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Medical Transport\n381\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Drugs or Alcohol\n36\n\n\n\n\n\n\n\n\n\n\n\nPlots\n\n\nBy year\n\n\nBy speed\n\n\n\n\n\n\nVehicle-Pedestrian Incidents by Year\n\n\n\n\n\n\nVehicle Pedestrian Incidents by Posted Speed Limit\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we can put this in our page_filable()\n\npage_fillable(dash_content)\n\n\n\n\n\nVehicle-Pedestrian Incidents for Chattanooga, TN (2018-2023)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of Incidents\n631\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Fatalities\n40\n\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Medical Transport\n381\n\n\n\n\n\n\n\n\n\n\n\n\nInvolved Drugs or Alcohol\n36\n\n\n\n\n\n\n\n\n\n\n\nPlots\n\n\nBy year\n\n\nBy speed\n\n\n\n\n\n\nVehicle-Pedestrian Incidents by Year\n\n\n\n\n\n\nVehicle Pedestrian Incidents by Posted Speed Limit"
  },
  {
    "objectID": "location-services/tutorials/shiny-dash/index.html#source-code",
    "href": "location-services/tutorials/shiny-dash/index.html#source-code",
    "title": "Dashboard using {arcgis}",
    "section": "Source code",
    "text": "Source code\n\n\n\napp.R\n\nlibrary(sf)\nlibrary(bslib)\nlibrary(dplyr)\nlibrary(arcgis)\nlibrary(plotly)\nlibrary(bsicons)\nlibrary(ggplot2)\nlibrary(leaflet)\n\ntheme_set(theme_minimal())\n\ndata_url &lt;- \"https://services.arcgis.com/UnTXoPXBYERF0OH6/arcgis/rest/services/Vehicle_Pedestrian_Incidents/FeatureServer\"\n\n# open the feature server\ncrash_server &lt;- arc_open(data_url)\n\n# fetch individual layers\nincidents &lt;- get_layer(crash_server, 1)\nhotspots &lt;- get_layer(crash_server, 2)\n\n# bring them into memory as sf objects\ninci_sf &lt;- arc_select(incidents)\nhs_sf &lt;- arc_select(hotspots)\n\n# count the number of incidents by year\nannual_counts &lt;- inci_sf |&gt;\n  st_drop_geometry() |&gt;\n  mutate(year = lubridate::year(Incident_Date)) |&gt;\n  group_by(year) |&gt;\n  count() |&gt;\n  ungroup()\n\n# make annual incidents plot\ngg_annual &lt;- ggplot(annual_counts, aes(year, n)) +\n  geom_line() +\n  geom_point(size = 3) +\n  labs(\n    x = \"Year\",\n    y = \"Incidents\"\n  )\n\n# count incidents by speed\nspeed_counts &lt;- inci_sf |&gt;\n  st_drop_geometry() |&gt;\n  count(Posted_Speed) |&gt;\n  filter(!is.na(Posted_Speed))\n\ngg_speed &lt;- ggplot(speed_counts, aes(Posted_Speed, n)) +\n  geom_col() +\n  labs(\n    x = \"Posted Speed Limit (miles per hour)\",\n    y = \"Incidents\"\n  )\n\nplot_tab &lt;- navset_card_tab(\n  title = \"Plots\",\n  nav_panel(\n    \"By year\",\n    card_title(\"Vehicle-Pedestrian Incidents by Year\"),\n    ggplotly(gg_annual)\n  ),\n  nav_panel(\n    \"By speed\",\n    card_title(\"Vehicle Pedestrian Incidents by Posted Speed Limit\"),\n    ggplotly(gg_speed)\n  )\n)\n\nn_incidents &lt;- count(inci_sf) |&gt;\n  pull(n)\n\nn_medical_transit &lt;- inci_sf |&gt;\n  count(Involved_Medical_Transport) |&gt;\n  filter(Involved_Medical_Transport == \"Yes\") |&gt;\n  pull(n)\n\nn_fatalities &lt;- inci_sf |&gt;\n  count(Involved_Fatal_Injury) |&gt;\n  filter(Involved_Fatal_Injury == \"Yes\") |&gt;\n  pull(n)\n\nn_alc_drug &lt;- inci_sf |&gt;\n  filter(Drug_Involved == \"Yes\" | Alcohol_Involved == \"Yes\") |&gt;\n  count() |&gt;\n  pull(n)\n\ninci_card &lt;- value_box(\n  \"Number of Incidents\",\n  n_incidents,\n  showcase = bs_icon(\"person\")\n)\n\nfatalities_card &lt;- value_box(\n  \"Total Fatalities\",\n  n_fatalities,\n  showcase = bs_icon(\"heartbreak\")\n)\n\nmedical_card &lt;- value_box(\n  \"Involved Medical Transport\",\n  n_medical_transit,\n  showcase = bs_icon(\"heart-pulse\")\n)\n\ndrugs_card &lt;- value_box(\n  \"Involved Drugs or Alcohol\",\n  n_alc_drug,\n  showcase = bs_icon(\"capsule\")\n)\n\nstats &lt;- layout_columns(\n  inci_card,\n  fatalities_card,\n  medical_card,\n  drugs_card,\n  col_widths = 6\n)\n\n\nrhs_col &lt;- layout_columns(\n  stats,\n  plot_tab,\n  col_widths = 12\n)\n\n\n# create labels vector to pass to leaflet\ngi_labels &lt;- c(\n  \"Not Significant\",\n  \"Hot Spot with 90% Confidence\",\n  \"Hot Spot with 95% Confidence\",\n  \"Hot Spot with 99% Confidence\"\n)\n\nhexes &lt;- hs_sf |&gt;\n  transmute(\n    classification = case_when(\n      Gi_Bin == 0 ~ gi_labels[1],\n      Gi_Bin == 1 ~ gi_labels[2],\n      Gi_Bin == 2 ~ gi_labels[3],\n      Gi_Bin == 3 ~ gi_labels[4]\n    )\n  ) |&gt;\n  st_transform(4326)\n\npal &lt;- colorFactor(\n  palette = c(\"#c6c6c3\", \"#c8976e\", \"#be6448\", \"#af3129\"),\n  levels = gi_labels\n)\n\nmap &lt;- leaflet() |&gt;\n  addProviderTiles(\"Esri.WorldGrayCanvas\") |&gt;\n  addPolygons(\n    data = hexes,\n    fillColor = ~pal(classification),\n    color = \"#c6c6c3\",\n    weight = 1,\n    fillOpacity = 0.8\n  ) |&gt;\n  addLegend(\n    pal = pal,\n    values = gi_labels,\n    opacity = 1,\n    title = \"Hot Spot Classification\"\n  ) |&gt;\n  setView(-85.3, 35.04, 12.5)\n\nmap_card &lt;- card(\n  card_header(\"Vehicle-Pedestrian Incidents for Chattanooga, TN (2018-2023)\"),\n  map\n)\n\ndash_content &lt;- layout_columns(\n  map_card,\n  rhs_col,\n  col_widths = c(8, 4)\n)\n\nui &lt;- page_fillable(\n  dash_content\n)\n\n# print ui to open the dashboard\nui"
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html",
    "href": "location-services/workflows/add-delete-update.html",
    "title": "Editing Features",
    "section": "",
    "text": "Programmatically, adding, deleting, or updating features using {arcgis} is a straightforward process. In this workflow, we illustrate how to add, update, or delete features from an existing hosted feature layer or table.\nWe will go over the functions:"
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html#pre-requisites",
    "href": "location-services/workflows/add-delete-update.html#pre-requisites",
    "title": "Editing Features",
    "section": "Pre-requisites",
    "text": "Pre-requisites\nWe will use the the North Carolina SIDS dataset we created in the Publishing from R tutorial. To follow along, be sure that you have followed that tutorial and have a FeatureLayer that you can modify. If you have not yet configured your environment to authorize with an online portal, start at Connecting to your portal."
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html#adding-features",
    "href": "location-services/workflows/add-delete-update.html#adding-features",
    "title": "Editing Features",
    "section": "Adding features",
    "text": "Adding features\nFor this example, we will add a single feature to the North Carolina SIDS dataset that is a summary over the entire state. Before we can begin, we must load the package and authorize ourselves as a user.\n\nlibrary(arcgis)\n\ntoken &lt;- auth_code()\nset_auth_token(token)\n\n#&gt; Token set to environment variable `ARCGIS_TOKEN`\nNext, we will create the feature that we want to add using the sf package. We’ll read in the nc.shp file from the sf package.\n\nlibrary(sf)\nnc_sf &lt;- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc_sf\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nLet’s calculate the average birth rate, SIDS rate, and the non-white birth rate and SIDS rate for the entire state. We will add this as a single feature to our existing feature layer. To do so, we will use the R package dplyr for manipulating our data.\n\nlibrary(dplyr)\n\nnc_summary &lt;- nc_sf |&gt;  \n  summarise(\n1    across(\n2      .cols = c(ends_with(\"74\"), ends_with(\"79\")),\n3      .fns = mean\n    ),\n4    NAME = \"Total\"\n  ) \n\nnc_summary\n\n\n1\n\nThe across() function applies a function to multiple columns at once.\n\n2\n\nWe specify the columns we will be applying a function to in .cols. We use the tidyselect helpers to catch any columns that end with 74 or 79.\n\n3\n\nThe .fns argument specifies which functions will be applied to the columns. In this case, we apply on the mean() function to calculate the average.\n\n4\n\nThe NAME field is set manually to the value of \"Total\" to indicate that it is not a county.\n\n\n\n\nSimple feature collection with 1 feature and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 1 × 8\n  BIR74 SID74 NWBIR74 BIR79 SID79 NWBIR79 NAME                          geometry\n  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;               &lt;MULTIPOLYGON [°]&gt;\n1 3300.  6.67   1051. 4224.  8.36   1353. Total (((-75.97629 36.51793, -75.9772…\n\n\nIn order to add this new aggregate feature to the FeatureLayer we must create a reference to the layer using arc_open().\n\nnc_url &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\" \n\nnc &lt;- arc_open(nc_url)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n\n\nThe url you use here will be different than the one you see. Be sure to grab the correct url from the content listing for your item.\nNow that we have a FeatureLayer object we can add features to it using add_features(). There are a few key arguments to the function:\n\nx is the FeatureLayer object that we want to add features to\n.data is an sf object that we want to add to the FeatureLayer\nmatch_on determines how to match sf columns to FeatureLayer fields\n\nBy default, add_features() will compare the column names of the sf object to that of the FeatureLayer. We can find the field names and aliases for a FeatureLayer by using the list_fields() function. Pass the results to tibble::as_tibble() to make them more readable.\nSince we know that the column names match those of the FeatureLayer, we can pass nc_summary directly to add_feature().\n\nadd_res &lt;- add_features(nc, nc_summary)\nadd_res\n\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\n\n\n\n\n\n\nTip\n\n\n\nIf you are adding many features at one time, consider changing the value of chunk_size. By default, add_features() will add up to 2000 features at a time and send the requests in parallel. Depending on the geometry type and precision, it may be worthwhile to make that number smaller. If the data are truly massive, consider breaking up the task into smaller manageable chunks.\n\n\nOnce we’ve added the results to the FeatureLayer, we may want to refresh the object to catch any important changes to the metadata.\n\nnc &lt;- refresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nWe can see that the FeatureLayer now has 101 features as opposed to the original 100. To sanity check, we can query nc to see how the value comes back.\n\nnc_avgs &lt;- nc |&gt; \n  filter(NAME == \"Total\") |&gt; \n  collect()\n\nnc_avgs\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101   NA        NA    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36..."
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html#updating-features",
    "href": "location-services/workflows/add-delete-update.html#updating-features",
    "title": "Editing Features",
    "section": "Updating Features",
    "text": "Updating Features\nIn the previous section we added a new feature that is the average of our numeric columns and stored the results in the variable nc_avgs. When looking at it, we can see that the AREA AND PERIMETER values are missing. These might be helpful at a later point.\nIn this section we will use the function update_features() to modify these values. First, let’s create a new object called to_update that has the AREA and PERIMETER computed.\n\nnc_area_perim &lt;- nc_avgs |&gt; \n  mutate(\n    AREA = st_area(geometry) / 1e10,\n    PERIMETER = s2::s2_perimeter(geometry) / 1e5\n  )\n\nnc_area_perim\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id           AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259 [m^2]  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...\nLike add_features(), we need to be able to match columns to their respective fields. The match_on argument is used to specify if the column names match the field name or field alias.\nIn the case of update_features() we also need to be able to match the features in the sf dataset to the exact feature in the FeatureLayer. We do this by providing the object ID of the feature. This tells ArcGIS which features we are actually going to update.\nWhen using update_features() we should be aware that every column present in the sf object will be updated including the geometry. For this reason, we should select only those columns which we truly wish to update.\n\nto_update &lt;- nc_area_perim |&gt; \n  st_drop_geometry() |&gt; \n  select(object_id, AREA, PERIMETER)\n\nto_update\n\nHere we use sf::st_drop_geometry()to remove the geometry of our object since we do not want to update the geometry in our FeatureLayer. We also only select the object_id, AREA, and PERIMETER columns so that we do not make errant updates.\n\nupdate_res &lt;- update_features(nc, to_update)\n\n$updateResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\nOur update process was successful! We can repeat our previous query to verify this.\n\n nc |&gt; \n  filter(NAME == \"Total\") |&gt; \n  collect()\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id     AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36..."
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html#deleting-features",
    "href": "location-services/workflows/add-delete-update.html#deleting-features",
    "title": "Editing Features",
    "section": "Deleting Features",
    "text": "Deleting Features\nWhile add_features() and update_features() had a very similar syntax, delete_features() has a somewhat different interface. We have 3 different ways in which we can delete features. Here we will explore only two of them.\nWe can delete features based on object IDs or a SQL where clause. Let’s explore deleting features based on object IDs. To do so, we need to pass the FeatureLayer obejct as the first argument to delete_features(). The second argument is a numeric vector of the IDs we want to delete. The ID 101 is the new feature that we created.\n\ndelete_res &lt;- delete_features(nc, object_ids = 101)\ndelete_res\n\n$deleteResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\nWe can check to see if the delete worked by refreshing the layer and seeing the count that is printed out.\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nAlternatively, we can delete features based on a where clause. Say we wanted to delete all of the features where the BIR74 value was less than 1000. We can accomplish this using a where clause.\n\ndelete_res &lt;- delete_features(nc, where = \"BIR74 &lt; 1000\")\ndelete_res\n\n$deleteResults\n   objectId uniqueId globalId success\n1         2        2       NA    TRUE\n2         4        4       NA    TRUE\n3         7        7       NA    TRUE\n4         8        8       NA    TRUE\n5         9        9       NA    TRUE\n6        20       20       NA    TRUE\n7        21       21       NA    TRUE\n8        22       22       NA    TRUE\n9        32       32       NA    TRUE\n10       35       35       NA    TRUE\n11       38       38       NA    TRUE\n12       44       44       NA    TRUE\n13       45       45       NA    TRUE\n14       56       56       NA    TRUE\n15       58       58       NA    TRUE\n16       59       59       NA    TRUE\n17       73       73       NA    TRUE\n18       77       77       NA    TRUE\n19       78       78       NA    TRUE\n20       80       80       NA    TRUE\n21       83       83       NA    TRUE\n22       87       87       NA    TRUE\n23       90       90       NA    TRUE\nSuccessful deletes! Again, we can check to see the new count using refresh_layer().\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nLastly, if you want to delete every single feature. We can take advantage of the where clause again. If we set where = \"1 = 1\" that will evaluate TRUE for every single feature.\n\ndelete_res &lt;- delete_features(nc, where = \"1 = 1\")\ndelete_res\n\n$deleteResults\n   objectId uniqueId globalId success\n1         1        1       NA    TRUE\n2         3        3       NA    TRUE\n3         5        5       NA    TRUE\n4         6        6       NA    TRUE\n5        10       10       NA    TRUE\n6        11       11       NA    TRUE\n          ... Truncated ...\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nUsing delete_features(x, where = \"1 = 1\") is basically the equivalent of truncate_layer().\nCongratulations! You’ve now learned how to add features, update them, and delete them from a hosted FeatureLayer."
  },
  {
    "objectID": "location-services/workflows/overwrite-feature-service.html",
    "href": "location-services/workflows/overwrite-feature-service.html",
    "title": "Overwrite Hosted Feature Layer",
    "section": "",
    "text": "From time to time as the owner of a Feature Layer, you may need to completely overwrite the data in the service. Overwriting a web layer from ArcGIS Pro may lead to a loss of associated pop-ups and symbology. One way to get around this is to truncate the feature service and append new data to the same service.\nFor this example, we need to be the owner of a Feature Service. As such, we will use the North Carolina SIDS dataset we created in the Publishing from R tutorial. If you have not done that tutorial, complete it first."
  },
  {
    "objectID": "location-services/workflows/overwrite-feature-service.html#truncating-a-feature-layer",
    "href": "location-services/workflows/overwrite-feature-service.html#truncating-a-feature-layer",
    "title": "Overwrite Hosted Feature Layer",
    "section": "Truncating a Feature Layer",
    "text": "Truncating a Feature Layer\nTruncating a Feature Layer deletes every single record in the service and resets the auto-increment of the object ID. Truncating a service does not change the field definitions or permit us to add or remove fields. If you wish to do so, publish a new layer instead.\nBefore we can modify a service, we must first authorize ourselves with the portal. To do so we will use the auth_code() authorization flow. If you have not yet configured you environment to authorize with your portal, follow the Connecting to your Portal tutorial.\nFirst load arcgis.\n\nlibrary(arcgis)\n\nAttaching core arcgis packages:\n  - {arcgisutils} v0.1.0\n  - {arcgislayers} v0.1.0\nNext, authorize with the portal and set the access token.\n\ntoken &lt;- auth_code()\nset_auth_token(token)\n\nToken set to environment variable `ARCGIS_TOKEN`\nNow that we have verified our identity with our portal we can create a FeatureLayer object in R from our hosted service. From your content listing find the Feature Layer url.\n\n\n\n\n\n\nTip\n\n\n\nRevisit the “Obtaining a feature layer url” section of the Read hosted data tutorial if you forgot how to retrieve the service url.\n\n\n\nfurl &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\"\n\nnc &lt;- arc_open(furl)\nnc\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n\n\nThis is the url of your hosted feature service. Yours will be different than the URL shown here. Note that the /0 indicates the layer index. You can often copy the url from under the URL section on the right hand menu and append the /0 to it.\nBefore we can truncate the FeatureLayer, we should check to see that the layer itself supports this operation. The supportsTruncate attribute will return TRUE if we can truncate it. If not, we’re out of luck and need to create an entirely new service!\n\nnc[[\"supportsTruncate\"]]\n\nSince we know that we can truncate the service, we can go ahead and do so.\n\ntruncate_res &lt;- truncate_layer(nc)\ntruncate_res\n\nWe store the result into truncate_res to see the results. Let’s now go ahead and refresh our layer and check to see if the changes have taken place.\n\nnc &lt;- refresh_layer(nc)\nnc\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCapabilities: Create,Delete,Query,Update,Editing\nAfter refreshing the layer we can see that there are now 0 features! Success! There are still 15 fields and we still have the same name and geometry type."
  },
  {
    "objectID": "location-services/workflows/overwrite-feature-service.html#adding-features",
    "href": "location-services/workflows/overwrite-feature-service.html#adding-features",
    "title": "Overwrite Hosted Feature Layer",
    "section": "Adding features",
    "text": "Adding features\nNow that we have deleted all of the features of the layer, lets go ahead and add some new ones. Let’s read the nc.shp file from sf into memory, give it a slight modification, and add those features to our service.\n\nlibrary(sf)\n\nLinking to GEOS 3.11.2, GDAL 3.7.2, PROJ 9.3.0; sf_use_s2() is TRUE\n\nnc_sf &lt;- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc_sf\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nRather than publish the polygons as they are, let’s calculate the convex hull of each shape and publish those.\n\nnc_convex &lt;- st_convex_hull(nc_sf)\nplot(st_geometry(nc_convex))\n\nLet’s take this sf object and add them as features to our now empty FeatureLayer. To add features, we use the add_features() function. The first argument is the FeatureLayer (or Table) that we are adding features to. The second is the sf object that we will be adding to the layer.\n\n\n\n\n\n\nTip\n\n\n\nIt is important to note that the column names of the sf object must match the names of the fields in the FeatureLayer, otherwise arcgis does not know which column matches which field.\n\n\n\nadd_res &lt;- add_features(nc, nc_convex)\n\nWarning: CRS missing from `x` cannot verify matching CRS.\nWe receive a warning because there is no spatial reference in the hosted FeatureLayer after truncating. Print the add_res object to see if each feature was successfully added.\n\nhead(add_res)\n\n    objectId uniqueId globalId success\n1          1        1       NA    TRUE\n2          2        2       NA    TRUE\n3          3        3       NA    TRUE\n4          4        4       NA    TRUE\n5          5        5       NA    TRUE\n6          6        6       NA    TRUE\nNow that we have added our features, let us refresh the layer again.\n\nnc &lt;- refresh_layer(nc)\n\n&lt;FeatureLayer&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nIf you view the hosted Feature Layer in the map viewer, you should now see the convex hulls."
  },
  {
    "objectID": "location-services/connecting-to-a-portal.html",
    "href": "location-services/connecting-to-a-portal.html",
    "title": "Connect to your Portal",
    "section": "",
    "text": "In order to create content, interact with non-public items, save geocoding results, or use POI data with the Places Service, you will need to authenticate through ArcGIS Online, ArcGIS Enterprise, or Platform.",
    "crumbs": [
      "Authentication",
      "Authenticating with R"
    ]
  },
  {
    "objectID": "location-services/connecting-to-a-portal.html#obtaining-a-client-id",
    "href": "location-services/connecting-to-a-portal.html#obtaining-a-client-id",
    "title": "Connect to your Portal",
    "section": "Obtaining a Client ID",
    "text": "Obtaining a Client ID\nIf a client ID is not provided to you by an administrator and you have the ability to create content items, you can create one.\nYou can do so by creating an application item.\n\nLog in to your ArcGIS Online or ArcGIS Enterprise organization\nNavigate to the Content tab\nClick New Item\nSelect Application\n\n\n\nChoose Other application as your Application Type\nGive the item an informative name such as r-arcgis\n\nOptionally, specify the folder, tags, and summary as well.\n\n\n\n\nYou will be directed to the item details page of the newly created application where you can see your credentials. Do not share these.",
    "crumbs": [
      "Authentication",
      "Authenticating with R"
    ]
  },
  {
    "objectID": "location-services/connecting-to-a-portal.html#authorizing",
    "href": "location-services/connecting-to-a-portal.html#authorizing",
    "title": "Connect to your Portal",
    "section": "Authorizing",
    "text": "Authorizing\nFirst, load the library.\nlibrary(arcgis)\n#&gt; Attaching core arcgis packages:\n#&gt;   - {arcgisutils} v0.1.0\n#&gt;   - {arcgislayers} v0.1.0\n\nCode flow\nThe OAuth2 Code Flow is a process where a user authorizes an application to act on their behalf by granting a temporary access token. This type of authorization permits the application to take actions on the user’s behalf for the duration of the access token. Learn more about how ArcGIS uses OAuth2.0.\nRunning auth_code() will open a tab in your browser to begin the code flow. If you are authorizing to an ArcGIS Enterprise portal, ensure that you set the ARCGIS_HOST environment variable correctly and that you have restarted your R session.\ntoken &lt;- auth_code()\nYou will be prompted to sign in to your portal.\n\nOnce you’ve signed in, copy the code that appears, and return to R. Enter the code into the console without any modifications and press enter.\n\nYour authorization will have completed.\ntoken\n#&gt; &lt;httr2_token&gt;\n#&gt; token_type: bearer\n#&gt; access_token: &lt;REDACTED&gt;\n#&gt; expires_at: 2023-03-03 13:21:40\n#&gt; refresh_token: &lt;REDACTED&gt;\n#&gt; username: your-user\n#&gt; ssl: TRUE\n#&gt; refresh_token_expires_in: 1209599\n\n\n\n\n\n\nWarning\n\n\n\nAuthorization tokens are temporary and will expire. If you encounter an invalid token error, you might need to generate a new token.\n\n\nTo make this token easily accessible to {arcgis}, use set_arc_token() which sets the token in dedicated authorization token environment.\nset_arc_token(token)\n\n\nClient flow\nAlternatively, you can authorize using the client OAuth2 flow. This will authorize the application you created and not ourselves. Because of this, you cannot use the client flow to create or modify content.\nThe client flow has the benefit of being non-interactive, though.\ntoken &lt;- auth_client()\nset_arc_token(token)",
    "crumbs": [
      "Authentication",
      "Authenticating with R"
    ]
  }
]