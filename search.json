[
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "R-ArcGIS Bridge",
    "section": "",
    "text": "{arcgisbinding} tutorial notebooks\nGeoprocessing tools using R scripts\n\n\n\n\n\nAuthorize to ArcGIS Online or an Enterprise Portal"
  },
  {
    "objectID": "tutorials.html#vignettes-tutorials",
    "href": "tutorials.html#vignettes-tutorials",
    "title": "R-ArcGIS Bridge",
    "section": "",
    "text": "{arcgisbinding} tutorial notebooks\nGeoprocessing tools using R scripts\n\n\n\n\n\nAuthorize to ArcGIS Online or an Enterprise Portal"
  },
  {
    "objectID": "tutorials.html#notes",
    "href": "tutorials.html#notes",
    "title": "R-ArcGIS Bridge",
    "section": "Notes",
    "text": "Notes\nTutorial/Workflow vs Vignette\nAnalogous to Python API\nVignette -&gt; Guide Tutorial -&gt; Sample\n\nTutorial would be a end to end process\n\nread in, manipulate, etc, then write back up to online\nHow to batch geocode and upload results to AGOL\nHow to create a GP tool (best practices)\nRead from an enterprise geodatabase / sde file\nusing R for something specific that you dont do in pro (for binding) or analysis tools\n\nVignette: how to understand / interact with a specific piece of code\n\nauthorization\ncreating new packages\n\ntips for developers"
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html",
    "href": "location-services/workflows/add-delete-update.html",
    "title": "Editing Features",
    "section": "",
    "text": "Programmatically, adding, deleting, or updating features using {arcgis} is a deceptively simple process. In this workflow, we illustrate how to add, update, or delete features from an existing hosted Feature Layer or Table.\nWe will go over the functions:"
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html#pre-requisites",
    "href": "location-services/workflows/add-delete-update.html#pre-requisites",
    "title": "Editing Features",
    "section": "Pre-requisites",
    "text": "Pre-requisites\nWe will use the the North Carolina SIDS dataset we created in the Publishing from R tutorial. To follow along be sure that you have followed that tutorial and have a FeatureLayer that you can modify. If you have not yet configured your environment to authorize with an online portal, start at Connecting to your portal."
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html#adding-features",
    "href": "location-services/workflows/add-delete-update.html#adding-features",
    "title": "Editing Features",
    "section": "Adding features",
    "text": "Adding features\nFor this example, we will add a single feature to the North Carolina SIDS dataset that is a summary over the entire state. Before we can begin, we must load the package and authorize ourselves as a user.\n\nlibrary(arcgis)\n\ntoken &lt;- auth_code()\nset_auth_token(token)\n\n#&gt; Token set to environment variable `ARCGIS_TOKEN`\nNext, we will create the feature that we want to add using the sf package. We’ll read in the nc.shp file from the sf package.\n\nlibrary(sf)\nnc_sf &lt;- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc_sf\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nLet’s calculate the average birth rate, SIDS rate, and the non-white birth rate and SIDS rate for the entire state. We will add this as a single feature to our existing feature layer. To do so, we will use the R package dplyr for manipulating our data.\n\nlibrary(dplyr)\n\nnc_summary &lt;- nc_sf |&gt;  \n  summarise(\n1    across(\n2      .cols = c(ends_with(\"74\"), ends_with(\"79\")),\n3      .fns = mean\n    ),\n4    NAME = \"Total\"\n  ) \n\nnc_summary\n\n\n1\n\nThe across() function applies a function to multiple columns at once.\n\n2\n\nWe specify the columns we will be apply a function to in .cols. We use the tidyselect helpers to catch any columns that end with 74 or 79.\n\n3\n\nThe .fns argument specifies which functions will be applied to the columns. In this case, we apply on the mean() function to calculate the average.\n\n4\n\nThe NAME field is set manually to the value of \"Total\" to indicate that it is not a county.\n\n\n\n\nSimple feature collection with 1 feature and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 1 × 8\n  BIR74 SID74 NWBIR74 BIR79 SID79 NWBIR79 NAME                          geometry\n  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;               &lt;MULTIPOLYGON [°]&gt;\n1 3300.  6.67   1051. 4224.  8.36   1353. Total (((-75.97629 36.51793, -75.9772…\n\n\nIn order to add this new aggregate feature to the FeatureLayer we must create a reference to the layer using arc_open().\n\nnc_url &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\" \n\nnc &lt;- arc_open(nc_url)\n\n&lt;FeatureLayer &lt;100 features, 15 fields&gt;&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n\n\nThe url you use here will be different than the one you see. Be sure to grab the correct url from the content listing.\nNow that we have a FeatureLayer object we can add features to it using add_features(). There are a few key arguments to the function:\n\nx is the FeatureLayer object that we want to add features to\n.data is an sf object that we want to add to the FeatureLayer\nmatch_on determines how to match sf columns to FeatureLayer fields\n\nBy default, add_features() will compare the column names of the sf object to that of the FeatureLayer. We can find the field names and aliases for a FeatureLayer by using the list_fields() function. Pass the results to tibble::as_tibble() to make them more readable.\nSince we know that the column names match those of the FeatureLayer we can pass nc_summary directly to add_feature().\n\nadd_res &lt;- add_features(nc, nc_summary)\nadd_res\n\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\n\n\n\n\n\n\nTip\n\n\n\nIf you are adding a lot of features at one time, consider changing the value of chunk_size. By default, add_features() will add up to 2000 features at a time and send the requests in parallel. Depending on the geometry type and precision, it may be worthwhile to make that number smaller. If the data are truly massive, consider breaking up the task into smaller manageable chunks.\n\n\nOnce we’ve added the results to the FeatureLayer, we may want to refresh the object to catch any important changes to the metadata.\n\nnc &lt;- refresh_layer(nc)\n\n&lt;FeatureLayer &lt;101 features, 15 fields&gt;&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nWe can see that the FeatureLayer now has 101 features as opposed to the original 100. To sanity check, we can query nc to see how the value comes back.\n\nnc_avgs &lt;- nc |&gt; \n  filter(NAME == \"Total\") |&gt; \n  collect()\n\nnc_avgs\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101   NA        NA    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36..."
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html#updating-features",
    "href": "location-services/workflows/add-delete-update.html#updating-features",
    "title": "Editing Features",
    "section": "Updating Features",
    "text": "Updating Features\nIn the previous section we added a new feature that is the average of our numeric columns and stored the results in the variable nc_totals. When looking at it, we can see that the AREA AND PERIMTER values are missing. These might be helpful at a later point.\nIn this section we will use the function update_features() to modify these values. First, let’s create a new object called to_update that has the AREA and PERIMETER computed.\n\nnc_area_perim &lt;- nc_avgs |&gt; \n  mutate(\n    AREA = st_area(geometry) / 1e10,\n    PERIMETER = s2::s2_perimeter(geometry) / 1e5\n  )\n\nnc_area_perim\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id           AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259 [m^2]  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...\nLike add_features(), we need to be able to match columns to their respective fields. The match_on argument is used to specify if the column names match the field name or field alias.\nIn the case of update_features() we also need to be able to match the features in the sf dataset to the exact feature in the FeatureLayer. We do this by providing the object ID of the feature. This tells ArcGIS which features we are actually going to update.\nWhen using update_features() we should be aware that every column present in the sf object will be updated including the geometry. For this reason, we should select only those columns which we truly wish to update.\n\nto_update &lt;- nc_area_perim |&gt; \n  st_drop_geometry() |&gt; \n  select(object_id, AREA, PERIMETER)\n\nto_update\n\nHere we use sf::st_drop_geometry()to remove the geometry of our object since we do not want to update the geometry in our FeatureLayer. We also only select the object_id, AREA, and PERIMETER columns so that we do not make an errant updates.\n\nupdate_res &lt;- update_features(nc, to_update)\n\n$updateResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\nOur update process was successful! We can repeat our previous query to verify this.\n\n nc |&gt; \n  filter(NAME == \"Total\") |&gt; \n  collect()\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id     AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36..."
  },
  {
    "objectID": "location-services/workflows/add-delete-update.html#deleting-features",
    "href": "location-services/workflows/add-delete-update.html#deleting-features",
    "title": "Editing Features",
    "section": "Deleting Features",
    "text": "Deleting Features\nWhile add_features() and update_features() had a very similar syntax, delete_features() has a somewhat different interface. We have 3 different ways in which we can delete features. Here we will explore only two of them.\nWe can delete features based on object IDs, or a SQL where clause. Let explore deleting features based on object IDs. To do so, we need to pass the FeatureLayer obejct as the first argument to delete_features() and the second argument is a numeric vector of the IDs we want to delete. The ID 101 is the new feature that we created.\n\ndelete_res &lt;- delete_features(nc, object_ids = 101)\ndelete_res\n\n$deleteResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\nWe can check to see if the delete worked by refreshing the laye and seeing the count that is printed out.\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer &lt;100 features, 15 fields&gt;&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nAlternatively, we can delete features based on a where clause. Say we wanted to delete all of the features where the BIR74 value was less than 1000. We can accomplish this using a where clause.\n\ndelete_res &lt;- delete_features(nc, where = \"BIR74 &lt; 1000\")\ndelete_res\n\n$deleteResults\n   objectId uniqueId globalId success\n1         2        2       NA    TRUE\n2         4        4       NA    TRUE\n3         7        7       NA    TRUE\n4         8        8       NA    TRUE\n5         9        9       NA    TRUE\n6        20       20       NA    TRUE\n7        21       21       NA    TRUE\n8        22       22       NA    TRUE\n9        32       32       NA    TRUE\n10       35       35       NA    TRUE\n11       38       38       NA    TRUE\n12       44       44       NA    TRUE\n13       45       45       NA    TRUE\n14       56       56       NA    TRUE\n15       58       58       NA    TRUE\n16       59       59       NA    TRUE\n17       73       73       NA    TRUE\n18       77       77       NA    TRUE\n19       78       78       NA    TRUE\n20       80       80       NA    TRUE\n21       83       83       NA    TRUE\n22       87       87       NA    TRUE\n23       90       90       NA    TRUE\nSuccessful deletes! Again, we can check to see the new count using refresh_layer().\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer &lt;77 features, 15 fields&gt;&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nLastly, if you want to delete every single feature. We can take advantage of the where clause again. If we set where = \"1 = 1\" that will evaluate TRUE for every single feature.\n\ndelete_res &lt;- delete_features(nc, where = \"1 = 1\")\ndelete_res\n\n$deleteResults\n   objectId uniqueId globalId success\n1         1        1       NA    TRUE\n2         3        3       NA    TRUE\n3         5        5       NA    TRUE\n4         6        6       NA    TRUE\n5        10       10       NA    TRUE\n6        11       11       NA    TRUE\n          ... Truncated ...\n\nrefresh_layer(nc)\n\n&lt;FeatureLayer &lt;0 features, 15 fields&gt;&gt;\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\nUsing delete_features(x, where = \"1 = 1\") is basically the equivalent of truncate_layer().\nCongratulations! You’ve now learned how to add features, update them, and delete them from a hosted FeatureLayer."
  },
  {
    "objectID": "location-services/read-data.html",
    "href": "location-services/read-data.html",
    "title": "Read hosted data",
    "section": "",
    "text": "ArcGIS Online and Enterprise hosted Feature Layers can easily be read into R as {sf} objects using{arcgislayers}.\nThis tutorial will teach you the basics of reading data using arcgis."
  },
  {
    "objectID": "location-services/read-data.html#objective",
    "href": "location-services/read-data.html#objective",
    "title": "Read hosted data",
    "section": "Objective",
    "text": "Objective\nThe objective of this tutorial is to teach you how to\n\nread in a population dataset from ArcGIS Online\napply a filter to a Feature Layer\nread only specified columns\nfind a Feature Layer url"
  },
  {
    "objectID": "location-services/read-data.html#obtaining-a-feature-layer-url",
    "href": "location-services/read-data.html#obtaining-a-feature-layer-url",
    "title": "Read hosted data",
    "section": "Obtaining a feature layer url",
    "text": "Obtaining a feature layer url\nFor this example we will read in population data of major US cities from ArcGIS Online.\nWe will use the functions arc_open() and arc_select() to read data from ArcGIS Online into R. However, these functions require the url of the hosted feature service. To find this, we can navigate to the item in our portal.\n When you scroll down, on the right hand side, you will see a button to view the service itself.\n\nClicking this will bring us to the Feature Service itself. Inside of a Feature Server there may be many layers or table that we can use. In this case, there is only one layer. Click the hyperlinked USA Major Cities.\n\nNow we will be in the Feature Layer itself.\n\nNavigate to your browsers search bar, and you can copy the url\nhttps://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Major_Cities_/FeatureServer/0"
  },
  {
    "objectID": "location-services/read-data.html#opening-a-feature-layer",
    "href": "location-services/read-data.html#opening-a-feature-layer",
    "title": "Read hosted data",
    "section": "Opening a Feature Layer",
    "text": "Opening a Feature Layer\nBefore we can read in the Feature Layer, we need to load the arcgis R package. If you do not have arcgis installed, install it with pak::pak(\"r-arcgis/arcgis\").\n\n\n{pak} is an R package that makes it faster and easier to install R packages. If you do not have it installed, run install.packages(\"pak\") first.\n\nlibrary(arcgis)\n\nAttaching core arcgis packages:\n  - {arcgisutils} v0.1.0\n  - {arcgislayers} v0.1.0\n\n\nLet’s store the Feature Layer url in an object called furl (as in feature layer url).\n\nfurl &lt;- \"https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Major_Cities_/FeatureServer/0\"\n\nWe then pass this variable to arc_open() and save it to flayer (feature layer).\n\nflayer &lt;- arc_open(furl)\nflayer\n\n&lt;FeatureLayer &lt;4186 features, 11 fields&gt;&gt;\nName: USA Major Cities\nGeometry Type: esriGeometryPoint\nCRS: 4326\nCapabilities: Query,Extract\n\n\narc_open() will create a FeatureLayer object. Under this hood this is really just a list with all of the feature layer’s metadata.\n\n\n\n\n\n\nFeatureLayer details for the curious\n\n\n\n\n\nThe FeatureLayer object is obtained by adding ?f=json to the feature layer url and processing the json. All of the metadata in there is stored in the FeatureLayer object. You can see this by running unclass(flayer). Be warned! It gets messy.\n\n\n\nWith this FeatureLayer object, we can read data from the service into R using it!"
  },
  {
    "objectID": "location-services/read-data.html#reading-from-a-feature-layer",
    "href": "location-services/read-data.html#reading-from-a-feature-layer",
    "title": "Read hosted data",
    "section": "Reading from a Feature Layer",
    "text": "Reading from a Feature Layer\nOnce we have a FeatureLayer object we can read its data into memory using the arc_select() function. By default, if we use arc_select() on a FeatureLayer without any additional arguments, the entire service will be brought into memory.\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to not try and read in more data than you need! Reading an entire feature services is fine for datasets in the realm of 0 - 5,000 features. But when we have more than 10,000 features performance and memory may be throttled.\nExceptionally detailed geometries require more data to be transferred across the web and may be slower to process.\n\n\n\ncities &lt;- arc_select(flayer)\ncities\n\nSimple feature collection with 4185 features and 11 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -159.3191 ymin: 19.58272 xmax: -68.67922 ymax: 64.86928\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   OBJECTID           NAME CLASS STATE_ABBR STATE_FIPS PLACE_FIPS POPULATION\n1         1      Alabaster  city         AL         01    0100820      33284\n2         2    Albertville  city         AL         01    0100988      22386\n3         3 Alexander City  city         AL         01    0101132      14843\n4         4       Anniston  city         AL         01    0101852      21564\n5         5         Athens  city         AL         01    0102956      25406\n6         6         Atmore  city         AL         01    0103004       8391\n7         7         Auburn  city         AL         01    0103076      76143\n8         8       Bessemer  city         AL         01    0105980      26019\n9         9     Birmingham  city         AL         01    0107000     200733\n10       10         Calera  city         AL         01    0111416      16494\n   POP_CLASS POP_SQMI   SQMI CAPITAL                   geometry\n1          6   1300.7  25.59          POINT (-86.81782 33.2445)\n2          6    827.9  27.04         POINT (-86.21205 34.26421)\n3          6    337.4  43.99         POINT (-85.95631 32.94309)\n4          6    469.9  45.89          POINT (-85.81986 33.6565)\n5          6    625.8  40.60          POINT (-86.9508 34.78484)\n6          5    382.5  21.94         POINT (-87.49009 31.02226)\n7          7   1234.5  61.68         POINT (-85.48999 32.60691)\n8          6    641.8  40.54          POINT (-86.9563 33.40092)\n9          8   1342.2 149.55          POINT (-86.79647 33.5288)\n10         6    674.0  24.47          POINT (-86.74549 33.1244)\n\n\nWe store the results of arc_select() into the object cities. The result is an sf object that we can now work with using sf and any other R package we’d like.\n\nSpecifying output fields\nIn some cases we may have Feature Layers with many fields that we might not want. We can specify which fields we want to return to R by using the fields argument.\n\n\n\n\n\n\nTip\n\n\n\nIt’s always good to only read in the data that you need. Adding unneeded fields uses more memory and takes longer to process.\n\n\nfields takes a character vector of field names. To see which fields are available in a Feature Layer you can use the utility function list_fields().\n\nfields &lt;- list_fields(flayer)\nfields[, 1:4]\n\n         name                      type                  alias      sqlType\n1    OBJECTID          esriFieldTypeOID               OBJECTID sqlTypeOther\n2        NAME       esriFieldTypeString                   Name sqlTypeOther\n3       CLASS       esriFieldTypeString                  Class sqlTypeOther\n4  STATE_ABBR       esriFieldTypeString     State Abbreviation sqlTypeOther\n5  STATE_FIPS       esriFieldTypeString             State FIPS sqlTypeOther\n6  PLACE_FIPS       esriFieldTypeString             Place FIPS sqlTypeOther\n7  POPULATION      esriFieldTypeInteger  2020 Total Population sqlTypeOther\n8   POP_CLASS esriFieldTypeSmallInteger       Population Class sqlTypeOther\n9    POP_SQMI       esriFieldTypeDouble People per square mile sqlTypeOther\n10       SQMI       esriFieldTypeDouble   Area in square miles sqlTypeOther\n11    CAPITAL       esriFieldTypeString                Capital sqlTypeOther\n\n\n\n\nFor the sake of readability, only the first 4 columns are displayed.\nLet’s try reading in only the \"STATE_ABBR\", \"POPULATION\", and \"NAME\" fields.\n\narc_select(\n  flayer, \n  fields = c(\"STATE_ABBR\", \"POPULATION\", \"NAME\")\n)\n\nSimple feature collection with 4185 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -159.3191 ymin: 19.58272 xmax: -68.67922 ymax: 64.86928\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   STATE_ABBR POPULATION           NAME                   geometry\n1          AL      33284      Alabaster  POINT (-86.81782 33.2445)\n2          AL      22386    Albertville POINT (-86.21205 34.26421)\n3          AL      14843 Alexander City POINT (-85.95631 32.94309)\n4          AL      21564       Anniston  POINT (-85.81986 33.6565)\n5          AL      25406         Athens  POINT (-86.9508 34.78484)\n6          AL       8391         Atmore POINT (-87.49009 31.02226)\n7          AL      76143         Auburn POINT (-85.48999 32.60691)\n8          AL      26019       Bessemer  POINT (-86.9563 33.40092)\n9          AL     200733     Birmingham  POINT (-86.79647 33.5288)\n10         AL      16494         Calera  POINT (-86.74549 33.1244)\n\n\n\n\nUsing SQL where clauses\nNot only can we limit the number of columns that we return from a Feature Layer, but we can also limit the number of rows that we have returned to us. This is very handy in the case of very, very, massive Feature Layers with hundreds of thousands of features. Reading all of those features into memory would be slow, costly (in terms of memory), and unnecessary!\nThe where argument of arc_select() permits us to provide a very simple SQL where clause to limit what we get back. Let’s explore the use of the where argument.\nLet’s modify our above arc_select() statement to return only the features in California. We do this by using the where clause STATE_ABBR = 'CA'\n\narc_select(\n  flayer,\n  where = \"STATE_ABBR = 'CA'\",\n  fields = c(\"STATE_ABBR\", \"POPULATION\", \"NAME\")\n)\n\nSimple feature collection with 498 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -124.1662 ymin: 32.57388 xmax: -114.5903 ymax: 40.93734\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   STATE_ABBR POPULATION         NAME                   geometry\n1          CA      38046     Adelanto  POINT (-117.4384 34.5792)\n2          CA      20299 Agoura Hills POINT (-118.7601 34.15363)\n3          CA      78280      Alameda  POINT (-122.2614 37.7672)\n4          CA      15314        Alamo POINT (-122.0307 37.84998)\n5          CA      20271       Albany POINT (-122.3002 37.88985)\n6          CA      82868     Alhambra POINT (-118.1355 34.08398)\n7          CA      52176  Aliso Viejo POINT (-117.7289 33.57922)\n8          CA      14696       Alpine POINT (-116.7585 32.84388)\n9          CA      42846     Altadena POINT (-118.1356 34.19342)\n10         CA      12042    Alum Rock  POINT (-121.8239 37.3694)\n\n\nWe can also consider finding only the places in the US with more than 1,000,000 people as well.\n\narc_select(\n  flayer,\n  where = \"POPULATION &gt; 1000000\",\n  fields = c(\"STATE_ABBR\", \"POPULATION\", \"NAME\")\n)\n\nSimple feature collection with 10 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -121.8864 ymin: 29.42354 xmax: -74.01013 ymax: 41.75649\nGeodetic CRS:  WGS 84\n   STATE_ABBR POPULATION         NAME                   geometry\n1          AZ    1608139      Phoenix POINT (-112.0739 33.44611)\n2          CA    3898747  Los Angeles POINT (-118.2706 34.05279)\n3          CA    1386932    San Diego POINT (-117.1456 32.72033)\n4          CA    1013240     San Jose POINT (-121.8864 37.33941)\n5          IL    2746388      Chicago POINT (-87.64715 41.75649)\n6          NY    8804190     New York POINT (-74.01013 40.71057)\n7          PA    1603797 Philadelphia POINT (-75.16099 39.95136)\n8          TX    1304379       Dallas POINT (-96.79576 32.77865)\n9          TX    2304580      Houston POINT (-95.36751 29.75876)\n10         TX    1434625  San Antonio  POINT (-98.4925 29.42354)\n\n\nNow let’s try combining both where clauses using and to find only the cities in California with a population greater than 1,000,000.\n\narc_select(\n  flayer,\n  where = \"POPULATION &gt; 1000000 and STATE_ABBR = 'CA'\",\n  fields = c(\"STATE_ABBR\", \"POPULATION\", \"NAME\")\n)\n\nSimple feature collection with 3 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -121.8864 ymin: 32.72033 xmax: -117.1456 ymax: 37.33941\nGeodetic CRS:  WGS 84\n  STATE_ABBR POPULATION        NAME                   geometry\n1         CA    3898747 Los Angeles POINT (-118.2706 34.05279)\n2         CA    1386932   San Diego POINT (-117.1456 32.72033)\n3         CA    1013240    San Jose POINT (-121.8864 37.33941)"
  },
  {
    "objectID": "location-services/read-data.html#using-dplyr",
    "href": "location-services/read-data.html#using-dplyr",
    "title": "Read hosted data",
    "section": "Using dplyr",
    "text": "Using dplyr\nIf writing the field names out by hand and coming up with SQL where clauses isn’t your thing, that’s okay. We also provide dplyr::select() and dplyr::filter() methods for FeatureLayer objects.\nThe dplyr functionality is modeled off of dbplyr. The general concept is that we have a connection object that specifies what we will be querying against. Then we build up our queries using dplyr functions. Unlike using dplyr on data.frames, the results aren’t fetched eagerly. Instead they are lazy. With dbplyr we use the collect() function to execute a query and bring it into memory. The same is true with FeatureLayer objects.\nLet’s build up a query and see it in action! We need to load dplyr to bring the functions into scope.\n\nlibrary(dplyr)\n\nfl_query &lt;- flayer |&gt; \n  select(STATE_ABBR, POPULATION, NAME)\n\nfl_query\n\n&lt;FeatureLayer &lt;4186 features, 11 fields&gt;&gt;\nName: USA Major Cities\nGeometry Type: esriGeometryPoint\nCRS: 4326\nCapabilities: Query,Extract\nQuery:\n  outFields: STATE_ABBR,POPULATION,NAME\n\n\nAfter doing this, we can see that our FeatureLayer object now prints out a Query field with the outFields parameter set to the result of our select() function.\n\n\n\n\n\n\nA note for advanced useRs\n\n\n\n\n\nWe build up and store the query in the query attribute of a FeatureLayer object. It is a named list that will be passed directly to the API endpoint. The names match endpoint parameters.\n\nattr(fl_query, \"query\")\n\n$outFields\n[1] \"STATE_ABBR,POPULATION,NAME\"\n\n\nYou can also manually specify parameters using the update_params() function. Note that there is no parameter validation.\n\nupdate_params(fl_query, key = \"value\")\n\n&lt;FeatureLayer &lt;4186 features, 11 fields&gt;&gt;\nName: USA Major Cities\nGeometry Type: esriGeometryPoint\nCRS: 4326\nCapabilities: Query,Extract\nQuery:\n  outFields: STATE_ABBR,POPULATION,NAME\n  key: value\n\n\n\n\n\nWe can continue to build up our query using filter()\n\n\n\n\n\n\nTip\n\n\n\nOnly very basic filter statements are supported such as ==, &lt;, &gt;, etc.\n\n\n\nfl_query |&gt; \n  filter(POPULATION &gt; 1000000, STATE_ABBR = \"CA\")\n\n&lt;FeatureLayer &lt;4186 features, 11 fields&gt;&gt;\nName: USA Major Cities\nGeometry Type: esriGeometryPoint\nCRS: 4326\nCapabilities: Query,Extract\nQuery:\n  outFields: STATE_ABBR,POPULATION,NAME\n  where: POPULATION &gt; 1000000.0 AND 'CA'\n\n\nThe query is stored in the FeatureLayer object and will not be executed until we request it with collect().\n\nfl_query |&gt; \n  filter(POPULATION &gt; 1000000, STATE_ABBR == \"CA\") |&gt; \n  collect()\n\nSimple feature collection with 3 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -121.8864 ymin: 32.72033 xmax: -117.1456 ymax: 37.33941\nGeodetic CRS:  WGS 84\n  STATE_ABBR POPULATION        NAME                   geometry\n1         CA    3898747 Los Angeles POINT (-118.2706 34.05279)\n2         CA    1386932   San Diego POINT (-117.1456 32.72033)\n3         CA    1013240    San Jose POINT (-121.8864 37.33941)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R-ArcGIS Bridge",
    "section": "",
    "text": "The R-ArcGIS Bridge is a project designed to integrate the power of R with the greater ArcGIS ecosystem."
  },
  {
    "objectID": "index.html#integrate-with-arcgis-pro-arcgisbinding",
    "href": "index.html#integrate-with-arcgis-pro-arcgisbinding",
    "title": "R-ArcGIS Bridge",
    "section": "Integrate with ArcGIS Pro {arcgisbinding}",
    "text": "Integrate with ArcGIS Pro {arcgisbinding}\n{arcgisbinding},the first package created under the R-ArcGIS Bridge, is designed to bridge the powers of R and ArcGIS.\nUsing {arcgisbinding} you can read and write local data sources and take advantage of ArcGIS Pro’s projection engine.\n\nRead and write local data sources with arc.write() and arc.open()\nConvert to {sf} and {raster} objects with arc.data2sf() and arc.raster()\n\nGet started by installing {arcgisbinding}\n\nGeoprocessing Tools written in R\nThe true power of {arcgisbinding} lies in it’s ability to generate geoprocessing tools that execute R code.\nRead the documentation to get started building R-based geoprocessing tools!"
  },
  {
    "objectID": "index.html#interact-with-location-services",
    "href": "index.html#interact-with-location-services",
    "title": "R-ArcGIS Bridge",
    "section": "Interact with Location Services",
    "text": "Interact with Location Services\nThe {arcgis} metapackage provides access to Esri location services enabling users to read and write data from their hosted or on prem Portals.\nFollow along with the introduction tutorial to get started interacting with your organziation’s data directly from R!"
  },
  {
    "objectID": "index.html#our-r-packages",
    "href": "index.html#our-r-packages",
    "title": "R-ArcGIS Bridge",
    "section": "Our R-packages",
    "text": "Our R-packages\n\n\n\n{arcgisbinding}\nHarness the power of ArcGIS Pro from R.\n\n\n{arcgis}\nLocation services metapackage. Your one stop shop for all your location services needs!\n\n\n\n\n{arcgislayers}\nRead and write to Feature Services and much more with ArcGIS Location Services.\n\n\n{arcgisutils}\nPowers {arcgis} by providing functionality to authorize with your portal and convert to and from R objects and Esri JSON.\n\n\n\n\n{arcpbf}\nProcess FeatureCollection protocol buffers in R using the power of Rust!"
  },
  {
    "objectID": "index.html#not-sure-where-to-start",
    "href": "index.html#not-sure-where-to-start",
    "title": "R-ArcGIS Bridge",
    "section": "Not sure where to start?",
    "text": "Not sure where to start?\n\nRead and write Feature Services using {arcgis}\nCreate R based Geoprocessing tools\nAccess your enterprise geodatabase from R"
  },
  {
    "objectID": "arcgisbinding/installing-arcgisbinding.html",
    "href": "arcgisbinding/installing-arcgisbinding.html",
    "title": "Installing {arcgisbinding}",
    "section": "",
    "text": "arcgisbinding is an R package that enables communication between ArcGIS Pro and R. In order to use it, you must have a installation of ArcGIS Pro with a valid licenses as well as a supported version of R."
  },
  {
    "objectID": "arcgisbinding/installing-arcgisbinding.html#from-pro",
    "href": "arcgisbinding/installing-arcgisbinding.html#from-pro",
    "title": "Installing {arcgisbinding}",
    "section": "Install within ArcGIS Pro (recommended)",
    "text": "Install within ArcGIS Pro (recommended)\nIf you are working in Pro 2.0 or beyond you have access to the built-in ArcGIS bridge installer which streamlines the process of installing arcgisbinding. It allows you to select your desired installation of R, and makes checking the bridge for updates easy. To install the bridge in this scenario, you will do the following:\n\nOpen ArcGIS Pro and click on the ‘Project’ tab in your project.\nSelect Options on the blue, left-hand side panel and in the pop-up window, under Application, select ‘Geoprocessing’.\nUnder the R-ArcGIS Support options, select your desired R home directory.\n\n\n\n\n\n\n\nWarning\n\n\n\n\n\nNote: All versions of R installed on your computer will appear in the drop-down menu. Make sure the version you select is R 3.2.2 or later. However, if you have installed R to a location other than the default, you might need to navigate to that location using the browse button.\n\n\n\n\nIf you have never installed the arcgisbinding, you will see a warning indicating that you need to install the package to enable R to connect with ArcGIS Pro. When you click on the icon next to the warning you will be presented with options to automatically download and install arcgisbinding, to separately download the package, or to install the package from file. Select the first option to \"automatically download and install\" the arcgisbinding package.\nA pop-up window will appear to inform you there is a new arcgisbinding version and will ask you if you wish to install it. Select \"Yes\".\nA progress bar will appear to inform you of the status of the installation before showing an Output Message to report the final status. If you scroll down, you should see that the package arcgisbinding was successfully installed."
  },
  {
    "objectID": "arcgisbinding/installing-arcgisbinding.html#install-from-r",
    "href": "arcgisbinding/installing-arcgisbinding.html#install-from-r",
    "title": "Installing {arcgisbinding}",
    "section": "Install from R",
    "text": "Install from R\nAlternatively, you can install the binding directly from R if you so wish! Open RStudio, VS Code, or your favorite text editor and run the following from the console.\n install.packages(\n  \"arcgisbinding\", \n  repos = \"https://r.esri.com\", \n  type = \"win.binary\"\n )\nThis will install the package binary directly from our GitHub repository which stores the builds of the package. Note that installing this way still has the same requirements. The package is a Windows binary and must be installed on a Windows computer."
  },
  {
    "objectID": "arcgisbinding/installing-arcgisbinding.html#offline-installation",
    "href": "arcgisbinding/installing-arcgisbinding.html#offline-installation",
    "title": "Installing {arcgisbinding}",
    "section": "Offline Installation",
    "text": "Offline Installation\nMany users of the R-ArcGIS Pro bridge (arcgisbinding) work in a completely air-gapped environment where downloading external packages from the internet is not possible.\nIn order to install arcgisbinding in an air-gapped environment you must first download the package on an internet enabled machine and “sneakernet” it into your offline environment.\nTo download the package go to https://r.esri.com/bin/ and choose the version of arcgisbridge that matches your version of R.\nOnce you’ve moved the zip file onto your air-gapped machine you can install it using the install.packages() command.\ninstall.packages(\"path/to/arcgisbinding_1.0.1.306.zip\", repos = NULL)"
  },
  {
    "objectID": "arcgisbinding/installing-arcgisbinding.html#upgrading-arcgisbinding",
    "href": "arcgisbinding/installing-arcgisbinding.html#upgrading-arcgisbinding",
    "title": "Installing {arcgisbinding}",
    "section": "Upgrading {arcgisbinding}",
    "text": "Upgrading {arcgisbinding}\n\nUsing ArcGIS Pro\nIf you have installed arcgisbinding from within ArcGIS Pro, follow the instructions for installing within ArcGIS Pro.\nIf you have previously installed arcgisbinding, you will see an installed message that lets you know the version of your arcgisbinding package and allows you to check for updates, download the latest version, or update from a file. Check for updates and ensure you have the latest version of the arcgisbinding package. If prompted to update, click \"Yes\" and the latest version will automatically be installed.\n\n\nUsing R or offline\nTo upgrade your package using R or in an offline environment, repeat the steps above."
  },
  {
    "objectID": "geoprocessing-tools.html",
    "href": "geoprocessing-tools.html",
    "title": "Geoprocessing Tools",
    "section": "",
    "text": "Much like a python geoprocessing (GP) script tool, R based script tools can be created allowing you to create GP tools and toolboxes that utilize the power of R. The basic anatomy of an R script GP tool is like so:\n\n\nmy-geoprocessing-tool.R\n\n1tool_exec &lt;- function(in_params, out_params) {\n  # ... do things here.. \n2  out_params\n}\n\n\n1\n\nTwo arguments capture input and output parameters\n\n2\n\nOutput parameters are returned to be captured by Pro\n\n\nGP R script tools are defined in a standalone R script. The GP tool is defined by a function called tool_exec(). tool_exec() take two and only two arguments capturing input and output parameters. tool_exec() should always return the output parameter argument."
  },
  {
    "objectID": "geoprocessing-tools.html#overview",
    "href": "geoprocessing-tools.html#overview",
    "title": "Geoprocessing Tools",
    "section": "",
    "text": "Much like a python geoprocessing (GP) script tool, R based script tools can be created allowing you to create GP tools and toolboxes that utilize the power of R. The basic anatomy of an R script GP tool is like so:\n\n\nmy-geoprocessing-tool.R\n\n1tool_exec &lt;- function(in_params, out_params) {\n  # ... do things here.. \n2  out_params\n}\n\n\n1\n\nTwo arguments capture input and output parameters\n\n2\n\nOutput parameters are returned to be captured by Pro\n\n\nGP R script tools are defined in a standalone R script. The GP tool is defined by a function called tool_exec(). tool_exec() take two and only two arguments capturing input and output parameters. tool_exec() should always return the output parameter argument."
  },
  {
    "objectID": "geoprocessing-tools.html#input-and-output-parameters",
    "href": "geoprocessing-tools.html#input-and-output-parameters",
    "title": "Geoprocessing Tools",
    "section": "Input and Output Parameters",
    "text": "Input and Output Parameters\nAdditionally, there must be two arguments that correspond to input parameters and output parameters. The conventional name of these arguments are in_params and out_params. The first argument will always refer to the input parameters and the second to the outputs.\nin_params and out_params are named lists. The elements of these lists are determined by the direction of a parameter.\n\nIf the direction is Input it will be contained in in_params. Likewise, if the direction is Output, it will be contained in out_params."
  },
  {
    "objectID": "geoprocessing-tools.html#using-parameters",
    "href": "geoprocessing-tools.html#using-parameters",
    "title": "Geoprocessing Tools",
    "section": "Using parameters",
    "text": "Using parameters\nWe can extract values from the in_params and out_params lists by the name of the parameter.\n\n\n\n\n\n\nCaution\n\n\n\nThe name of the parameter must match that of the Name column in the Parameters option of the Tool Properties. It is not the Label column.\n\n\nFor example, if we wanted to parse the date parameter we could write our function like so:\ntool_exec &lt;- function(in_params, out_params) {\n  # fetch the date parameter\n  date_str &lt;- in_params[[\"date\"]]\n  \n  # parse it using {anytime}\n  clean_date &lt;- anytime::anytime(date_str)\n  \n  # ... do additional things\n  \n  # return values to ArcGIS Pro\n  out_params\n}\n\nReturning values to ArcGIS Pro\nYou may have noticed that at the end of the tool_exec() function we are returning the out_params object. If we do not return the output parameters back to Pro—by returning out_params—the outputs cannot be captured and used by Pro.\nNotably, the output parameters are useful in linking one tool to another, for example via use in ModelBuilder or in an arcpy script.\nSee Using R script tools with arcpy\n\n\nParameter types\nThere are number of different type of parameters that can be provided to a geoprocessing (GP) tool. The type of parameter that is chosen determines how that parameter will appear in the GP pane’s UI. Each parameter type can be represented by a basic scalar R type: integer, double, character, logical, or NULL.\n\n\n\n\n\n\nTip\n\n\n\nA scalar value is a vector with only a single element.\n\n\nIt is incumbent upon you to take these parameter inputs and use them appropriately in R. Not every type of parameter can be processed correctly by arcgisbinding. Below are some of the most common parameter types and how they are handled by arcgisbinding. This is not a complete enumeration by any means!\n\nData type mapping\n\n\n\n\n\n\nParameter Data Type\nR type\n\n\n\n\nString\ncharacter\n\n\nBoolean\nlogical\n\n\nDouble\nnumeric\n\n\nDate\ncharacter in the format of your system e.g. \"11/17/2023 4:35:57 PM\"\n\n\nField\ncharacter the field name of a feature class\n\n\nFolder\ncharacter absolute path e.g. \"C:\\\\Users\\username\\Documents\"\n\n\nFeature Class\ncharacterabsolute path e.g. \"C:\\\\Users\\username\\mydatabase.gdb\\\\feature_class\n\n\nSpatial Reference\ncharacter a string representation of the spatial reference e.g. \"PROJCS[\"....\"]\"\n\n\n\n\n\nMultiple Values\nWhen selecting the Multiple values check box in the parameter data type UI, users can then provide multiple inputs of that type.\n\nWhen this is done, each of the input values will be contained inside of a list. If you have multiple values ticked for the String type, you will get a list of scalar character vectors.\nThis is important so it bears repeating! When users provide multiple values they will be captured in R as a list of scalars. Meaning that if you have multiple String values you will not get a character vector with a length greater than one.\nTake the below input for example\n\nIn R we would get the list(\"string 1\", \"string 2\") and not c(\"string 1\", \"string 2\").\n\n\n\n\n\n\nTip\n\n\n\nTo turn a list of scalars of the same type—e.g. double, integer, logical, or character—into a vector you can use unlist(). For example unlist(list(\"string 1\", \"string 2\")) will give us c(\"string 1\", \"string 2\")."
  },
  {
    "objectID": "geoprocessing-tools.html#common-patterns",
    "href": "geoprocessing-tools.html#common-patterns",
    "title": "Geoprocessing Tools",
    "section": "Common Patterns",
    "text": "Common Patterns\n\nReading a Feature Class\nOften we you will want to read a feature class using arcgisbinding and bring the results into R as an sf object. To do his we will use the functions arc.open(), arc.select(), and arc.data2sf().\ntool_exec &lt;- function(in_params, out_params) {\n\n  fclass &lt;- arcgisbinding::arc.open(in_params[[\"fc_path\"]])\n  \n  fclass_selected &lt;- arcgisbinding::arc.select(\n    fclass,\n    # fields = c(\"optional\", \"fields\", \"to\", \"read\"),\n    # where_clause = \"optional sql where clause to filter\"\n  )\n  \n  fclass_sf &lt;- arcgisbinding::arc.data2sf(fclass_selected)\n}\n\n\n\n\n\n\nNote\n\n\n\nIf you are going to filter or select columns from your dataset consider doing that with the fields and where_clause arguments of arc.select() to reduce the amount of data read into memory.\narc.select() returns a data.frame with fields and a special geometry column which is incompatible with sf. We use arc.data2sf() to convert it to an sf object.\n\n\n\n\nWriting a Feature Class\nIt is quite common to write the results of an analysis to a file geodatabase. This can be done with arc.write(). Typically, the we will capture the output path to write to in the out_params list object as a Feature Class type parameter.\narc.write() requires two arguments. The first is the output path to write to and the second is the object to write. The accepted type of objects are data.frame, sf, RasterLayer or RasterBrick.\n\n\n\n\n\n\nNote\n\n\n\nAs of Nov 2023 {terra} is not supported but we are actively working on this.\n\n\ntool_exec &lt;- function(in_params, out_params) {\n  \n  # extract the path to write to\n  out_fp &lt;- out_params[[\"output_fclass\"]]\n  \n  # write the `sf_object` to a geodatabase\n  arcgisbinding::arc.write(out_fp, sf_object)\n  \n}\n\n\nInstalling Required Packages\nWhen you share your R based GP tools with other users there is a good chance that they do not have the packages that your script tool needs to execute code. In this case, we should install the required packages the first time the script tool is executed.\nIn our script tool we should check to see if the required package is installed and if not, install it. We can write a helper function to include at the top of our script if we have multiple packages to check.\ninstall_if_not &lt;- function(pkg) {\n  if (!requireNamespace(pkg)) {\n    message(\"Installing required package `{\", pkg, \"}`\")\n    install.packages(pkg)\n  }\n}\nThis function uses requireNamespace() which attempts to load the provided package. If it succeeds, it returns TRUE, if not it returns FALSE. We check to see if it returns FALSE and if so, we install the package and print an informative message.\nFor example if we need to use the package {spdep} and its not installed it will print the message and install it.\ntool_exec &lt;- function(in_params, out_params) {\n  # check for required paackages \n  install_if_not(\"spdep\")\n  \n  # do other thigns with spdep\n  # ...\n}"
  },
  {
    "objectID": "geoprocessing-tools.html#using-progressors",
    "href": "geoprocessing-tools.html#using-progressors",
    "title": "Geoprocessing Tools",
    "section": "Using Progressors",
    "text": "Using Progressors\nGeoprocessing tools have a progressor, which includes both a progress label and a progress bar. The default progressor continuously moves back and forth to indicate the script is running. Using arc.progress_label() and arc.progress_pos() allows fine control over the script progress. Updating the progressor isn’t necessary, but is useful in situations where solely outputting messages to the dialog is insufficient to communicate script progress.\n\n\n\n\n\n\nDefault Progressor\n\n\n\n\n\n\n\nStep Progressor\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRead more in the Understanding the progressor in script tools article.\n\n\nUsing arc.progress_label() allows control over the label that is displayed at the top of the running script. For example, it might be used to display the current step of the analysis taking place. Using arc.progress_pos() allows control over the progressor position displayed at the top of the running script. The position is an integer percentage, 0 to 100, that the progress bar should be set to, with 100 indicating the script has completed (100%).\nlibrary(arcgisbinding)\n\ntool_exec &lt;- function(in_params, out_params) {\n  \n  # read feature class \n  arc.progress_label(\"Reading Feature Class\")\n  fclass &lt;- arc.open(in_params[[\"input_fclass\"]])\n  \n  # convert to sf\n  arc.progress_label(\"Converting Feature Class to sf\")\n  sf_obj &lt;- arc.data2sf(arc.select(fclass))\n  \n  # do other things \n  arc.progress_label(\"Doing other computations\")\n  \n  return(out_params)\n}"
  },
  {
    "objectID": "geoprocessing-tools.html#arcpy-integration",
    "href": "geoprocessing-tools.html#arcpy-integration",
    "title": "Geoprocessing Tools",
    "section": "Using R script tools with arcpy",
    "text": "Using R script tools with arcpy"
  },
  {
    "objectID": "geoprocessing-tools.html#dependent-parameters",
    "href": "geoprocessing-tools.html#dependent-parameters",
    "title": "Geoprocessing Tools",
    "section": "Dependent Parameters",
    "text": "Dependent Parameters\n\nAutopopulate field drop-down using dependent parameter"
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "Packages",
    "section": "",
    "text": "For ArcGIS Pro users\n\nThe original R-ArcGIS Bridge package. arcgisbinding interacts with ArcGIS Pro to provide native reading and writing capabilities to local data sources as well as enables R based geoprocessing script tools."
  },
  {
    "objectID": "packages.html#arcgisbinding",
    "href": "packages.html#arcgisbinding",
    "title": "Packages",
    "section": "",
    "text": "For ArcGIS Pro users\n\nThe original R-ArcGIS Bridge package. arcgisbinding interacts with ArcGIS Pro to provide native reading and writing capabilities to local data sources as well as enables R based geoprocessing script tools."
  },
  {
    "objectID": "packages.html#arcgis",
    "href": "packages.html#arcgis",
    "title": "Packages",
    "section": "{arcgis}",
    "text": "{arcgis}\nFor analysts & data scientists\n\narcgis is a metapackage that loads all location services packages for you."
  },
  {
    "objectID": "packages.html#arcgislayers",
    "href": "packages.html#arcgislayers",
    "title": "Packages",
    "section": "{arcgislayers}",
    "text": "{arcgislayers}\nFor analysts & data scientists\n\nInterfaces with Feature Services and Image Servers. Enables you to read and write to services directly from R."
  },
  {
    "objectID": "packages.html#arcgisutils",
    "href": "packages.html#arcgisutils",
    "title": "Packages",
    "section": "{arcgisutils}",
    "text": "{arcgisutils}\nFor Package Developers\n\nA low-level package to handle authorization and conversion to and from Esri json formats."
  },
  {
    "objectID": "packages.html#arcpbf",
    "href": "packages.html#arcpbf",
    "title": "Packages",
    "section": "{arcpbf}",
    "text": "{arcpbf}\nFor Package Developers \n\nRead ArcGIS Protocol Buffer format (PBF) from R. Utilized in processing responses from REST API requests."
  },
  {
    "objectID": "location-services/connecting-to-a-portal.html",
    "href": "location-services/connecting-to-a-portal.html",
    "title": "Connecting to your Portal",
    "section": "",
    "text": "In order to read content items that do not have a “Public” Sharing level (), or to write to or modify existing content items that you are an owner of, you will need to be authorized.\nAuthorization is done using OAuth2. There are two ways to authorize with OAuth2: either by using a a code or a client flow. In most cases code based authorization is recommended.\nThe first step of authorizing is creating a client ID."
  },
  {
    "objectID": "location-services/connecting-to-a-portal.html#obtaining-a-client-id",
    "href": "location-services/connecting-to-a-portal.html#obtaining-a-client-id",
    "title": "Connecting to your Portal",
    "section": "Obtaining a Client ID",
    "text": "Obtaining a Client ID\nIf a client ID is not provided to you by an admin and you have the ability to create content items, you can create one.\nYou can do so by creating an application item.\n\nLog in to your ArcGIS Online or ArcGIS Enterprise organization\nNavigate to the Contents tab\nClick New Item\nSelect Application\n\n\n\nChoose Other application as your Application Type\nGive the item an informative name such as r-arcgis\n\n\n\nYou will be directed to the content page where you can see your credentials. Do not share these."
  },
  {
    "objectID": "location-services/connecting-to-a-portal.html#securing-your-credentials",
    "href": "location-services/connecting-to-a-portal.html#securing-your-credentials",
    "title": "Connecting to your Portal",
    "section": "Securing your credentials",
    "text": "Securing your credentials\nBy default, packages in the {arcgis} meta-package are configured to work with ArcGIS Online. arcgis utilizes environment variables to determine how requests are crafted and where requests are made. These environment variables are:\n\nARCGIS_HOST\nARCGIS_CLIENT\nARCGIS_USER\nARCGIS_SECRET\nARCGIS_TOKEN\n\n\n\n\n\n\n\nEnvironment variable descriptions\n\n\n\n\n\n\nARCGIS_HOST is used to to determine where authorization takes place. By default, this is \"https://www.arcgis.com\". This is because the packages, by default, interact with ArcGIS Online. To use a different portal, you will need to modify the ARCGIS_HOST path to url of that portal.\nARCGIS_USER variable is used to determine who actions are performed on behalf of. Notably, it is used in functions that modify or create resource such as functions from arcgislayers: create_service(), add_item(), and publish_item().\nARCGIS_CLIENT and ARCGIS_SECRET environment variables are used only in the auth_client() OAuth2 client flow authorization. See the article on authorization for more.\nARCGIS_TOKEN is used to fetch a users access token. These are retrieved using the various auth_ functions of arcgisutils and set using set_auth_token(). Alternatively, the ARCGIS_TOKEN can be set to an API key.\n\n\n\n\n\nSetting your credentials in .Renviron\nEnvironment variables should never be included in your code. Instead, they should be stored in an external environment file such as an .Renvrion file. To modify your .Renviron run the following in your text editor\nusethis::edit_r_environ()\n\n\n\n\n\n\n.Renviron scopes\n\n\n\n\n\n.Renviron files can be created at a user level or a project level. It is recommended to use project level .Renviron files when deploying scripts to production. If most of your work is interactive then a user level file is sufficient.\nProject scoped .Renviron files store environment variables that are available for the project only. The .Renviron is stored at the root folder level.\nUser scoped .Renviron files store environment variables in the user’s home directory. The environment variables will be available to you in any project you open. However, if you share your project, the environment variables will not be shared with it.\n\n\n\nYou .Renviron file will now be opened for you to edit. Fill in the environment variables ARCGIS_CLIENT and ARCGIS_SECRET from the content item we just created.\nARCGIS_CLIENT=your-client-id\nARCGIS_SECRET=your-super-secret-key\nARCGIS_HOST=https://your-portal.com/\nARCGIS_USER=your-user-name\n\n\n\n\n\n\nWarning\n\n\n\nDo not put environment variable values in quotation marks.\nIf you are using ArcGIS Online, you do not need to set the environment variable ARCGIS_HOST.\n\n\nEnvironment variables will not be set automatically. To register the new environment variables restart your R session."
  },
  {
    "objectID": "location-services/connecting-to-a-portal.html#authorizing",
    "href": "location-services/connecting-to-a-portal.html#authorizing",
    "title": "Connecting to your Portal",
    "section": "Authorizing",
    "text": "Authorizing\nFirst, load the library.\nlibrary(arcgis)\n#&gt; Attaching core arcgis packages:\n#&gt;   - {arcgisutils} v0.1.0\n#&gt;   - {arcgislayers} v0.1.0\n\nCode flow\nNext run auth_code() which will open a tab in your browser. If you are authorizing to an ArcGIS Enterprise portal ensure that you set the ARCGIS_HOST environment variable correctly and that you restarted your R session.\ntoken &lt;- auth_code()\nYou will be prompted to sign in to your portal.\n\nOnce you’ve signed in, copy the code that appears, and return to R. Enter the code into the console without any modifications and press enter.\n\nYour authorization will have completed.\ntoken\n#&gt; &lt;httr2_token&gt;\n#&gt; token_type: bearer\n#&gt; access_token: &lt;REDACTED&gt;\n#&gt; expires_at: 2023-03-03 13:21:40\n#&gt; refresh_token: &lt;REDACTED&gt;\n#&gt; username: your-user\n#&gt; ssl: TRUE\n#&gt; refresh_token_expires_in: 1209599\nWe now need to set this token to the ARCGIS_SECRET environment variable. We do this with set_auth_token().\nset_auth_token(token)\n#&gt; Token set to environment variable `ARCGIS_TOKEN`\n\n\nClient flow\nAlternatively, we can authorize using the client OAuth2 flow. This will authorize the application we created and not ourselves. Because of this we cannot use the client flow to create or modify content.\nThe client flow has the benefit of being non-interactive, though.\ntoken &lt;- auth_client()\nset_auth_token(token)\n#&gt; Token set to environment variable `ARCGIS_TOKEN`\n\n\nUsing ArcGIS Pro & {arcgisbinding}\nIf you are a user of ArcGIS Pro and have arcgisbinding installed, you can use auth_binding() to utilize the tokens that result from arc.check_portal(). auth_binding() has the benefit of being non-interactive and authorizes you as a user. You can use auth_binding() for non-interactive work that creates or modifies existing content.\ntoken &lt;- auth_binding()\nset_auth_token(token)\n#&gt; Token set to environment variable `ARCGIS_TOKEN`"
  },
  {
    "objectID": "location-services/workflows/overwrite-feature-service.html",
    "href": "location-services/workflows/overwrite-feature-service.html",
    "title": "Overwrite Hosted Feature Layer",
    "section": "",
    "text": "From time to time as the owner of a Feature Layer, you may need to completely overwrite the data in the service. Overwriting a web layer from ArcGIS Pro may lead to a loss of associated pop-ups and symbology. One way to get around this is to truncate the feature service and append new data to the same service.\nFor this example, we need to be the owner of a Feature Service. As such, we will use the North Carolina SIDS dataset we created in the Publishing from R tutorial. If you have not done that tutorial, complete it first."
  },
  {
    "objectID": "location-services/workflows/overwrite-feature-service.html#truncating-a-feature-layer",
    "href": "location-services/workflows/overwrite-feature-service.html#truncating-a-feature-layer",
    "title": "Overwrite Hosted Feature Layer",
    "section": "Truncating a Feature Layer",
    "text": "Truncating a Feature Layer\nTruncating a Feature Layer deletes every single record in the service and resets the auto-increment of the object ID. Truncating a service does not change the field definitions or permit us to add or remove fields to it. If you wish to do so, publish a new layer instead.\nBefore we can modify a service, we must first authorize ourselves with the portal. To do so we will use the auth_code() authorization flow. If you have not yet configured you environment to authorize with your portal, follow the Connecting to your Portal tutorial.\nFirst load arcgis.\n\nlibrary(arcgis)\n\n#&gt; Attaching core arcgis packages:\n#&gt;   - {arcgisutils} v0.1.0\n#&gt;   - {arcgislayers} v0.1.0\nNext, authorize with the service itself and set the access token.\n\ntoken &lt;- auth_code()\nset_auth_token(token)\n\n#&gt; Token set to environment variable `ARCGIS_TOKEN`\nNow that we have verified our identity with our portal we can create a FeatureLayer object from our hosted service. From your content listing find the Feature Layer url.\n\n\n\n\n\n\nTip\n\n\n\nRevisit the “Obtaining a feature layer url” section of the Read hosted data tutorial if you forgot how to retrieve the service url.\n\n\n\nfurl &lt;- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\"\n\nnc &lt;- arc_open(furl)\nnc\n\n#&gt; &lt;FeatureLayer &lt;100 features, 15 fields&gt;&gt;\n#&gt; Name: North Carolina SIDS\n#&gt; Geometry Type: esriGeometryPolygon\n#&gt; CRS: 4267\n#&gt; Capabilities: Create,Delete,Query,Update,Editing\n\n\nThis is the url of your hosted feature service. This will be different than what is here. Note that the /0 indicates the layer index. You can often copy the url from under the URL section on the right hand menu and append the /0 to it.\nBefore we can truncate the FeatureLayer, we should check to see that the layer itself supports this operation. The supportsTruncate attribute will return TRUE if we can truncate it. If not, we’re out of luck and need to create an entirely new service!\n\nnc[[\"supportsTruncate\"]]\n\nSince we know that we can truncate the service, we can go ahead and do so.\n\ntruncate_res &lt;- truncate_layer(nc)\ntruncate_res\n\nWe store the result into truncate_res to see the results. Let’s now go ahead and refresh our layer and check to see if the changes have taken place.\n\nnc &lt;- refresh_layer(nc)\nnc\n\n#&gt; &lt;FeatureLayer &lt;0 features, 15 fields&gt;&gt;\n#&gt; Name: North Carolina SIDS\n#&gt; Geometry Type: esriGeometryPolygon\n#&gt; Capabilities: Create,Delete,Query,Update,Editing\nAfter refreshing the layer we can see that there are now 0 features! Success! There are still 15 fields and we still have the same name and geometry type."
  },
  {
    "objectID": "location-services/workflows/overwrite-feature-service.html#adding-features",
    "href": "location-services/workflows/overwrite-feature-service.html#adding-features",
    "title": "Overwrite Hosted Feature Layer",
    "section": "Adding features",
    "text": "Adding features\nNow that we have deleted all of the features of the layer, lets go ahead and add some new ones. Let’s read the nc.shp file from sf into memory, give it a slight modification, and add those features to our service.\n\nlibrary(sf)\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\nnc_sf &lt;- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc_sf\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nRather than publish the polygons as they are, let’s calculate the convex hull of each shape and publish those.\n\nnc_convex &lt;- st_convex_hull(nc_sf)\nplot(st_geometry(nc_convex))\n\nLet’s take this sf object and add them as features to our now empty FeatureLayer. To add features we use the add_features() function. The first argument is the FeatureLayer (or Table) that we are adding features to. The second is the sf object that we will be adding to the layer.\n\n\n\n\n\n\nTip\n\n\n\nIt is important to note that the column names of the sf object must match the names of the fields in the FeatureLayer otherwise arcgis does not know which column matches which field.\n\n\n\nadd_res &lt;- add_features(nc, nc_convex)\n\n#&gt; Warning: CRS missing from `x` cannot verify matching CRS.\nWe receive a warning because there is no spatial reference in the hosted FeatureLayer after truncating. Print the add_res object to see if each feature was successfully added.\n\nhead(add_res)\n\n#&gt;     objectId uniqueId globalId success\n#&gt; 1          1        1       NA    TRUE\n#&gt; 2          2        2       NA    TRUE\n#&gt; 3          3        3       NA    TRUE\n#&gt; 4          4        4       NA    TRUE\n#&gt; 5          5        5       NA    TRUE\n#&gt; 6          6        6       NA    TRUE\nNow that we have added our features, let us refresh the layer again.\n\nnc &lt;- refresh_layer(nc)\n\n#&gt; &lt;FeatureLayer &lt;100 features, 15 fields&gt;&gt;\n#&gt; Name: North Carolina SIDS\n#&gt; Geometry Type: esriGeometryPolygon\n#&gt; CRS: 4267\n#&gt; Capabilities: Create,Delete,Query,Update,Editing\nIf you view the hosted Feature Layer in the map viewer, you should now see the convex hulls."
  },
  {
    "objectID": "location-services/publishing.html",
    "href": "location-services/publishing.html",
    "title": "Publishing from R",
    "section": "",
    "text": "While you may often consume data as an R user, you may also want to also publish data as a hosted feature service. In this tutorial we will go over how to publish an sf object  to ArcGIS Online or Enterprise."
  },
  {
    "objectID": "location-services/publishing.html#authorization",
    "href": "location-services/publishing.html#authorization",
    "title": "Publishing from R",
    "section": "Authorization",
    "text": "Authorization\nIn order to publish content to ArcGIS Online or Enterprise, we must first obtain an access token permitting us to do so.\n\n\n\n\n\n\nCaution\n\n\n\nIf you have not yet set up your R environment for authorization, see Connecting to your Portal. Ensure that the environment variables ARCGIS_CLIENT and ARCGIS_USER are set at minimum. If you are using Enterprise ensure that ARCGIS_HOST is properly set as well.\n\n\nWe must go through the code flow to set our credentials.\n\nlibrary(arcgis)\n\n1token &lt;- auth_code()\n2set_auth_token(token)\n#&gt; Token set to environment variable `ARCGIS_TOKEN`\n\n\n1\n\nWe create an access token\n\n2\n\nWe set it to an environment variable.\n\n\n\n\nNow that we have authorized to our Portal, we will be able to publish our content."
  },
  {
    "objectID": "location-services/publishing.html#publishing-sf-objects",
    "href": "location-services/publishing.html#publishing-sf-objects",
    "title": "Publishing from R",
    "section": "Publishing {sf} objects",
    "text": "Publishing {sf} objects\nTo publish an {sf} object to our portal, we can use the function publish_layer(). The publishing process requires us to add an item to our portal and publish it. The publish_layer() function handles these steps for us.\nLet’s read in the North Carolina SIDS dataset that comes packaged with sf and store it in an object called nc.\n\nnc &lt;- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc\n\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 &lt;dbl&gt;, SID79 &lt;dbl&gt;, NWBIR79 &lt;dbl&gt;,\n#   geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nNow that we have an sf object and we have authorized with our portal, all that’s left is to publish the item!\npublish_layer() has only two required arguments:\n\nx the sf object or data.frame\ntitle the title of layer we are creating\n\n\nres &lt;- publish_layer(nc, \"North Carolina SIDS\")\nres\n#&gt; $services\n#&gt;              type\n#&gt; 1 Feature Service\n#&gt;                                                                                             serviceurl\n#&gt; 1 https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North Carolina SIDS/FeatureServer\n#&gt;     size                                jobId                    serviceItemId\n#&gt; 1 125766 f14451a7-325b-40b0-85c3-534bcf122806 32511ce0413f40d08303e267a7093be0\n#&gt;                                                                                          encodedServiceURL\n#&gt; 1 https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer\n\nNow from your Portal’s Content listing you should see your feature service. If you open it up you should see something like the below."
  },
  {
    "objectID": "location-services/publishing.html#reading-the-published-feature-layer",
    "href": "location-services/publishing.html#reading-the-published-feature-layer",
    "title": "Publishing from R",
    "section": "Reading the published Feature Layer",
    "text": "Reading the published Feature Layer\nThe output of this function is a list that contains information about where the sf object was published. We can retrieve the encodedServiceUrl from the response and read the response.\n\nnc_fserver &lt;- arc_open(res[[c(\"services\", \"encodedServiceURL\")]])\nnc_fserver\n#&gt; &lt;FeatureServer &lt;1 layer, 0 tables&gt;&gt;\n#&gt; CRS: 4267\n#&gt; Capabilities: Create,Delete,Query,Update,Editing\n#&gt;   0: North Carolina SIDS (esriGeometryPolygon)\n\nYou’ll notice that this is a FeatureServer. All items that are published to a Portal become their own Feature Server with a single FeatureLayer.\nWe can extract a single layer from the FeatureServer using get_layer(). We provide the FeatureServer as the first argument and then the ID of the layer we want as the second argument.\n\nget_layer(nc_fserver, 0)\n#&gt; &lt;FeatureLayer &lt;100 features, 15 fields&gt;&gt;\n#&gt; Name: North Carolina SIDS\n#&gt; Geometry Type: esriGeometryPolygon\n#&gt; CRS: 4267\n#&gt; Capabilities: Create,Delete,Query,Update,Editing"
  },
  {
    "objectID": "location-services/publishing.html#publishing-data.frames",
    "href": "location-services/publishing.html#publishing-data.frames",
    "title": "Publishing from R",
    "section": "Publishing data.frames",
    "text": "Publishing data.frames\nPublishing a data.frame follows the same steps as those above. The difference is that it creates a Table object. Try repeating the same process but using the palmerpenguins dataset!\n\n# install.packages(\"palmerpenguins\")\npalmerpenguins::penguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npublish_layer(palmerpenguins::penguins, \"Palmer Penguins\")"
  }
]