{
  "hash": "c706eff598b79c948496983f7e6d31c9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Editing Features\"\nsubtitle: \"Learn to add, update, or delete features\"\nfreeze: true\n---\n\n\n\n\nProgrammatically, adding, deleting, or updating features using `{arcgis}` is a straightforward process. In this workflow, we illustrate how to add, update, or delete features from an existing hosted feature layer or table. \n\nWe will go over the functions:\n\n  - `add_features()`\n  - `update_features()`\n  - `delete_features()`\n  \n## Pre-requisites\n\nWe will use the the *North Carolina SIDS* dataset we created in the [**Publishing from R**](../publishing.qmd) tutorial. To follow along, be sure that you have followed that tutorial and have a `FeatureLayer` that you can modify. If you have not yet configured your environment to authorize with an online portal, start at [**Connecting to your portal**](../connecting-to-a-portal.qmd).\n\n## Adding features\n\nFor this example, we will add a single feature to the North Carolina SIDS dataset that is a summary over the entire state. Before we can begin, we must load the package and authorize ourselves as a user. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arcgis)\n\ntoken <- auth_code()\nset_auth_token(token)\n```\n:::\n\n```\n#> Token set to environment variable `ARCGIS_TOKEN`\n```\n\nNext, we will create the feature that we want to add using the `sf` package. We'll read in the `nc.shp` file from the `sf` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nnc_sf <- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 100 × 15\n    AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74\n   <dbl>     <dbl> <dbl>   <dbl> <chr> <chr>  <dbl>    <int> <dbl> <dbl>   <dbl>\n 1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10\n 2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10\n 3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208\n 4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123\n 5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066\n 6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954\n 7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115\n 8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254\n 9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748\n10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160\n# ℹ 90 more rows\n# ℹ 4 more variables: BIR79 <dbl>, SID79 <dbl>, NWBIR79 <dbl>,\n#   geometry <MULTIPOLYGON [°]>\n```\n\n\n:::\n:::\n\n\nLet's calculate the average birth rate, SIDS rate, and the non-white birth rate and SIDS rate for the entire state. We will add this as a single feature to our existing feature layer. To do so, we will use the R package [`dplyr`](https://dplyr.tidyverse.org/) for manipulating our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nnc_summary <- nc_sf |>  \n  summarise(\n    across( # <1>\n      .cols = c(ends_with(\"74\"), ends_with(\"79\")), # <2>\n      .fns = mean # <3>\n    ),\n    NAME = \"Total\" # <4>\n  ) \n\nnc_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n# A tibble: 1 × 8\n  BIR74 SID74 NWBIR74 BIR79 SID79 NWBIR79 NAME                          geometry\n  <dbl> <dbl>   <dbl> <dbl> <dbl>   <dbl> <chr>               <MULTIPOLYGON [°]>\n1 3300.  6.67   1051. 4224.  8.36   1353. Total (((-75.97629 36.51793, -75.9772…\n```\n\n\n:::\n:::\n\n1. The [`across()`](https://dplyr.tidyverse.org/reference/across.html) function applies a function to multiple columns at once.\n2. We specify the columns we will be applying a function to in `.cols`. We use the `tidyselect` helpers to catch any columns that end with `74` or `79`.\n3. The `.fns` argument specifies which functions will be applied to the columns. In this case, we apply on the `mean()` function to calculate the average. \n4. The `NAME` field is set manually to the value of `\"Total\"` to indicate that it is not a county. \n\nIn order to add this new aggregate feature to the `FeatureLayer` we must create a reference to the layer using `arc_open()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc_url <- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\" \n\nnc <- arc_open(nc_url)\n```\n:::\n\n```\n<FeatureLayer>\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n```\n:::{.aside}\nThe url you use here will be different than the one you see. Be sure to grab the correct url from the content listing for your item. \n:::\n\nNow that we have a `FeatureLayer` object we can add features to it using `add_features()`. There are a few key arguments to the function:\n\n- `x` is the `FeatureLayer` object that we want to add features to \n- `.data` is an `sf` object that we want to add to the `FeatureLayer`\n- `match_on` determines how to match sf columns to `FeatureLayer` fields\n\nBy default, `add_features()` will compare the column names of the `sf` object to that of the `FeatureLayer`. We can find the field names and aliases for a `FeatureLayer` by using the `list_fields()` function. Pass the results to `tibble::as_tibble()` to make them more readable.\n\nSince we know that the column names match those of the `FeatureLayer`, we can pass `nc_summary` directly to `add_feature()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_res <- add_features(nc, nc_summary)\nadd_res\n```\n:::\n\n```\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\n```\n\n:::{.callout-tip}\nIf you are adding many features at one time, consider changing the value of `chunk_size`. By default, `add_features()` will add up to 2000 features at a time and send the requests in parallel. Depending on the geometry type and precision, it may be worthwhile to make that number smaller. If the data are truly massive, consider breaking up the task into smaller manageable chunks. \n:::\n\nOnce we've added the results to the `FeatureLayer`, we may want to refresh the object to catch any important changes to the metadata. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc <- refresh_layer(nc)\n```\n:::\n\n```\n<FeatureLayer>\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n```\n\nWe can see that the `FeatureLayer` now has 101 features as opposed to the original 100. To sanity check, we can query `nc` to see how the value comes back.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc_avgs <- nc |> \n  filter(NAME == \"Total\") |> \n  collect()\n\nnc_avgs\n```\n:::\n\n```\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101   NA        NA    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...\n```\n\n## Updating Features\n\n\nIn the previous section we added a new feature that is the average of our numeric columns and stored the results in the variable `nc_avgs`. When looking at it, we can see that the `AREA` AND `PERIMETER` values are missing. These might be helpful at a later point. \n\nIn this section we will use the function `update_features()` to modify these values. First, let's create a new object called `to_update` that has the `AREA` and `PERIMETER` computed. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc_area_perim <- nc_avgs |> \n  mutate(\n    AREA = st_area(geometry) / 1e10,\n    PERIMETER = s2::s2_perimeter(geometry) / 1e5\n  )\n\nnc_area_perim\n```\n:::\n\n```\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id           AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259 [m^2]  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...\n```\n\nLike `add_features()`, we need to be able to match columns to their respective fields. The `match_on` argument is used to specify if the column names match the field name or field alias. \n\nIn the case of `update_features()` we also need to be able to match the features in the `sf` dataset to the _exact_ feature in the `FeatureLayer`. We do this by providing the object ID of the feature. This tells ArcGIS _which_ features we are actually going to update. \n\nWhen using `update_features()` we should be aware that _every_ column present in the `sf` object will be updated _including the geometry_. For this reason, we should select only those columns which we truly wish to update.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_update <- nc_area_perim |> \n  st_drop_geometry() |> \n  select(object_id, AREA, PERIMETER)\n\nto_update\n```\n:::\n\n\nHere we use `sf::st_drop_geometry()`to remove the geometry of our object since we do not want to update the geometry in our `FeatureLayer`. We also only select the `object_id`, `AREA`, and `PERIMETER` columns so that we do not make errant updates. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate_res <- update_features(nc, to_update)\n```\n:::\n\n```\n$updateResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\n```\n\nOur update process was successful! We can repeat our previous query to verify this. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n nc |> \n  filter(NAME == \"Total\") |> \n  collect()\n```\n:::\n\n```\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id     AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...\n```\n\n## Deleting Features\n\nWhile `add_features()` and `update_features()` had a very similar syntax, `delete_features()` has a somewhat different interface. We have 3 different ways in which we can delete features. Here we will explore only two of them.\n\nWe can delete features based on object IDs or a SQL where clause. Let's explore deleting features based on object IDs. To do so, we need to pass the `FeatureLayer` obejct as the first argument to `delete_features()`. The second argument is a numeric vector of the IDs we want to delete. The ID `101` is the new feature that we created. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndelete_res <- delete_features(nc, object_ids = 101)\ndelete_res\n```\n:::\n\n\n```\n$deleteResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\n```\n\nWe can check to see if the delete worked by refreshing the layer and seeing the count that is printed out. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrefresh_layer(nc)\n```\n:::\n\n```\n<FeatureLayer>\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n```\n\nAlternatively, we can delete features based on a `where` clause. Say we wanted to delete all of the features where the `BIR74` value was less than `1000`. We can accomplish this using a where clause. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndelete_res <- delete_features(nc, where = \"BIR74 < 1000\")\ndelete_res\n```\n:::\n\n```\n$deleteResults\n   objectId uniqueId globalId success\n1         2        2       NA    TRUE\n2         4        4       NA    TRUE\n3         7        7       NA    TRUE\n4         8        8       NA    TRUE\n5         9        9       NA    TRUE\n6        20       20       NA    TRUE\n7        21       21       NA    TRUE\n8        22       22       NA    TRUE\n9        32       32       NA    TRUE\n10       35       35       NA    TRUE\n11       38       38       NA    TRUE\n12       44       44       NA    TRUE\n13       45       45       NA    TRUE\n14       56       56       NA    TRUE\n15       58       58       NA    TRUE\n16       59       59       NA    TRUE\n17       73       73       NA    TRUE\n18       77       77       NA    TRUE\n19       78       78       NA    TRUE\n20       80       80       NA    TRUE\n21       83       83       NA    TRUE\n22       87       87       NA    TRUE\n23       90       90       NA    TRUE\n```\n\nSuccessful deletes! Again, we can check to see the new count using `refresh_layer()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrefresh_layer(nc)\n```\n:::\n\n```\n<FeatureLayer>\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n```\n\nLastly, if you want to delete _every single feature_. We can take advantage of the where clause again. If we set `where = \"1 = 1\"` that will evaluate `TRUE` for every single feature.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndelete_res <- delete_features(nc, where = \"1 = 1\")\ndelete_res\n```\n:::\n\n```\n$deleteResults\n   objectId uniqueId globalId success\n1         1        1       NA    TRUE\n2         3        3       NA    TRUE\n3         5        5       NA    TRUE\n4         6        6       NA    TRUE\n5        10       10       NA    TRUE\n6        11       11       NA    TRUE\n          ... Truncated ...\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrefresh_layer(nc)\n```\n:::\n\n```\n<FeatureLayer>\nName: North Carolina SIDS\nGeometry Type: esriGeometryPolygon\nCRS: 4267\nCapabilities: Create,Delete,Query,Update,Editing\n```\n\nUsing `delete_features(x, where = \"1 = 1\")` is basically the equivalent of `truncate_layer()`. \n\nCongratulations! You've now learned how to add features, update them, and delete them from a hosted `FeatureLayer`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}