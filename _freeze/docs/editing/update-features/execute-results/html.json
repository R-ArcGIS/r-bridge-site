{
  "hash": "ca8b525b1df3f025c22a9a7102c54cb1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Updating features\"\n---\n\n\n\n\nIn the previous section we added a new feature that is the average of our numeric columns and stored the results in the variable `nc_avgs`. When looking at it, we can see that the `AREA` AND `PERIMETER` values are missing. These might be helpful at a later point. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arcgis)\nset_arc_token(auth_code())\n\nnc_url <- \"https://services1.arcgis.com/hLJbHVT9ZrDIzK0I/arcgis/rest/services/North%20Carolina%20SIDS/FeatureServer/0\" \n\nnc <- arc_open(nc_url)\n```\n:::\n\n\n\nIn this section we will use the function `update_features()` to modify these values. First, let's create a new object called `to_update` that has the `AREA` and `PERIMETER` computed. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc_area_perim <- nc_avgs |> \n  mutate(\n    AREA = st_area(geometry) / 1e10,\n    PERIMETER = s2::s2_perimeter(geometry) / 1e5\n  )\n\nnc_area_perim\n```\n:::\n\n```\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id           AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259 [m^2]  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...\n```\n\nLike `add_features()`, we need to be able to match columns to their respective fields. The `match_on` argument is used to specify if the column names match the field name or field alias. \n\nIn the case of `update_features()` we also need to be able to match the features in the `sf` dataset to the _exact_ feature in the `FeatureLayer`. We do this by providing the object ID of the feature. This tells ArcGIS _which_ features we are actually going to update. \n\nWhen using `update_features()` we should be aware that _every_ column present in the `sf` object will be updated _including the geometry_. For this reason, we should select only those columns which we truly wish to update.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_update <- nc_area_perim |> \n  st_drop_geometry() |> \n  select(object_id, AREA, PERIMETER)\n\nto_update\n```\n:::\n\n\nHere we use `sf::st_drop_geometry()`to remove the geometry of our object since we do not want to update the geometry in our `FeatureLayer`. We also only select the `object_id`, `AREA`, and `PERIMETER` columns so that we do not make errant updates. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate_res <- update_features(nc, to_update)\n```\n:::\n\n```\n$updateResults\n  objectId uniqueId globalId success\n1      101      101       NA    TRUE\n```\n\nOur update process was successful! We can repeat our previous query to verify this. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n nc |> \n  filter(NAME == \"Total\") |> \n  collect()\n```\n:::\n\n```\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n  object_id     AREA PERIMETER CNTY_ CNTY_ID  NAME FIPS FIPSNO CRESS_ID   BIR74 SID74 NWBIR74   BIR79 SID79 NWBIR79                       geometry\n1       101 12.70259  33.58819    NA      NA Total   NA     NA       NA 3299.62  6.67 1050.81 4223.92  8.36 1352.81 MULTIPOLYGON (((-75.9248 36...\n```",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}